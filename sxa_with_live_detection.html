<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SXA â€” Performance Analysis</title>
  <link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=DM+Sans:ital,wght@0,300;0,400;0,500;0,600;0,700;1,400&family=JetBrains+Mono:wght@400;600&display=swap" rel="stylesheet">
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script crossorigin src="https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.5.1675469404/pose.min.js"></script>
  <style>
    *, *::before, *::after {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      --primary: #00E5FF;
      --primary-dim: #00B8CC;
      --accent: #FF3D71;
      --accent2: #AAFF00;
      --bg: #080C14;
      --bg-2: #0E1420;
      --bg-3: #141C2E;
      --bg-card: #111828;
      --border: rgba(255,255,255,0.07);
      --border-bright: rgba(0,229,255,0.25);
      --text: #E8EDF5;
      --text-dim: #6B7A96;
      --text-muted: #3D4A62;
      --success: #AAFF00;
      --warning: #FFB800;
      --error: #FF3D71;
      --font-display: 'Bebas Neue', sans-serif;
      --font-body: 'DM Sans', sans-serif;
      --font-mono: 'JetBrains Mono', monospace;
      --bg-light: rgba(255, 255, 255, 0.04);
      --text-light: #4B5A72;
    }

    html { scroll-behavior: smooth; }

    body {
      font-family: var(--font-body);
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      overflow-x: hidden;
    }

    /* Subtle grid background */
    body::before {
      content: '';
      position: fixed;
      inset: 0;
      background-image:
        linear-gradient(rgba(0,229,255,0.025) 1px, transparent 1px),
        linear-gradient(90deg, rgba(0,229,255,0.025) 1px, transparent 1px);
      background-size: 48px 48px;
      pointer-events: none;
      z-index: 0;
    }

    /* Glow accent top-right */
    body::after {
      content: '';
      position: fixed;
      top: -200px;
      right: -200px;
      width: 600px;
      height: 600px;
      background: radial-gradient(circle, rgba(0,229,255,0.06) 0%, transparent 70%);
      pointer-events: none;
      z-index: 0;
    }

    .app-container {
      position: relative;
      z-index: 1;
      max-width: 1440px;
      margin: 0 auto;
      padding: 24px 28px;
    }

    /* â”€â”€ HEADER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 20px 32px;
      margin-bottom: 28px;
      background: rgba(14, 20, 32, 0.8);
      backdrop-filter: blur(20px);
      border: 1px solid var(--border);
      border-radius: 16px;
      position: sticky;
      top: 16px;
      z-index: 100;
    }

    .logo {
      font-family: var(--font-display);
      font-size: 38px;
      letter-spacing: 3px;
      background: linear-gradient(120deg, var(--primary) 0%, #AAFF00 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      line-height: 1;
    }

    .tagline {
      font-size: 11px;
      letter-spacing: 2.5px;
      text-transform: uppercase;
      color: var(--text-dim);
      margin-top: 4px;
      font-weight: 500;
    }

    .header-badge {
      display: flex;
      align-items: center;
      gap: 8px;
      background: rgba(0,229,255,0.08);
      border: 1px solid var(--border-bright);
      border-radius: 100px;
      padding: 8px 16px;
    }

    .header-badge-dot {
      width: 7px;
      height: 7px;
      border-radius: 50%;
      background: var(--primary);
      box-shadow: 0 0 8px var(--primary);
      animation: pulse-dot 2s infinite;
    }

    @keyframes pulse-dot {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.5; transform: scale(0.8); }
    }

    .header-badge-text {
      font-size: 12px;
      font-weight: 600;
      color: var(--primary);
      letter-spacing: 1px;
      font-family: var(--font-mono);
    }

    /* â”€â”€ NAV TABS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .nav-tabs {
      display: flex;
      gap: 4px;
      background: var(--bg-2);
      border: 1px solid var(--border);
      padding: 6px;
      border-radius: 14px;
      margin-bottom: 28px;
      flex-wrap: wrap;
      overflow-x: auto;
    }

    .nav-tab {
      padding: 10px 20px;
      border: none;
      background: transparent;
      color: var(--text-dim);
      cursor: pointer;
      border-radius: 9px;
      font-weight: 600;
      font-size: 13px;
      transition: all 0.2s ease;
      font-family: var(--font-body);
      letter-spacing: 0.3px;
      white-space: nowrap;
    }

    .nav-tab:hover:not(:disabled) {
      background: rgba(255,255,255,0.06);
      color: var(--text);
    }

    .nav-tab.active {
      background: var(--primary);
      color: var(--bg);
      box-shadow: 0 0 20px rgba(0,229,255,0.3), 0 4px 12px rgba(0,0,0,0.3);
      font-weight: 700;
    }

    .nav-tab:disabled {
      opacity: 0.3;
      cursor: not-allowed;
    }

    /* â”€â”€ CONTENT CARD â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .content-card {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 20px;
      padding: 36px;
      position: relative;
      overflow: hidden;
    }

    .content-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 1px;
      background: linear-gradient(90deg, transparent, var(--primary), transparent);
      opacity: 0.4;
    }

    .module-title {
      font-family: var(--font-display);
      font-size: 36px;
      letter-spacing: 2px;
      color: var(--text);
      margin-bottom: 6px;
      line-height: 1.1;
    }

    .module-subtitle {
      color: var(--text-dim);
      font-size: 14px;
      margin-bottom: 36px;
      letter-spacing: 0.3px;
    }

    /* â”€â”€ UPLOAD ZONE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .upload-zone {
      border: 2px dashed rgba(0,229,255,0.2);
      border-radius: 16px;
      padding: 56px 48px;
      text-align: center;
      background: rgba(0,229,255,0.02);
      cursor: pointer;
      transition: all 0.3s ease;
      margin-bottom: 24px;
      position: relative;
    }

    .upload-zone::before {
      content: '';
      position: absolute;
      inset: -1px;
      border-radius: 17px;
      background: linear-gradient(135deg, rgba(0,229,255,0.1), transparent, rgba(170,255,0,0.1));
      opacity: 0;
      transition: opacity 0.3s;
    }

    .upload-zone:hover {
      border-color: rgba(0,229,255,0.5);
      background: rgba(0,229,255,0.04);
    }

    .upload-zone:hover::before { opacity: 1; }

    .upload-icon {
      font-size: 52px;
      margin-bottom: 20px;
      display: block;
      filter: drop-shadow(0 0 16px rgba(0,229,255,0.3));
    }

    .upload-text {
      font-size: 18px;
      color: var(--text);
      font-weight: 600;
      margin-bottom: 8px;
    }

    .upload-hint {
      font-size: 13px;
      color: var(--text-dim);
      font-family: var(--font-mono);
    }

    /* â”€â”€ BUTTONS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .button-group {
      display: flex;
      gap: 12px;
      justify-content: center;
      margin-top: 24px;
      flex-wrap: wrap;
    }

    .btn {
      padding: 13px 32px;
      border: none;
      border-radius: 10px;
      font-weight: 700;
      font-size: 13px;
      cursor: pointer;
      transition: all 0.25s ease;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      letter-spacing: 0.5px;
      font-family: var(--font-body);
    }

    .btn-primary {
      background: var(--primary);
      color: var(--bg);
      box-shadow: 0 0 24px rgba(0,229,255,0.25), 0 4px 16px rgba(0,0,0,0.3);
    }

    .btn-primary:hover:not(:disabled) {
      background: #1AECFF;
      box-shadow: 0 0 36px rgba(0,229,255,0.4), 0 6px 20px rgba(0,0,0,0.4);
      transform: translateY(-2px);
    }

    .btn-primary:disabled {
      opacity: 0.35;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    .btn-secondary {
      background: transparent;
      color: var(--primary);
      border: 1.5px solid rgba(0,229,255,0.4);
    }

    .btn-secondary:hover {
      background: rgba(0,229,255,0.06);
      border-color: var(--primary);
    }

    /* â”€â”€ ERROR â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .error-message {
      background: rgba(255,61,113,0.08);
      border: 1px solid rgba(255,61,113,0.3);
      border-radius: 14px;
      padding: 28px;
      margin: 24px 0;
      text-align: center;
    }

    .error-icon { font-size: 44px; margin-bottom: 14px; display: block; }
    .error-title { font-family: var(--font-display); font-size: 24px; letter-spacing: 1px; color: var(--error); margin-bottom: 8px; }
    .error-text { color: var(--text-dim); font-size: 15px; line-height: 1.6; }

    /* â”€â”€ STATUS BADGES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .status-badge {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 7px 16px;
      border-radius: 100px;
      font-size: 12px;
      font-weight: 700;
      margin-bottom: 20px;
      letter-spacing: 1px;
      font-family: var(--font-mono);
    }

    .status-analyzing {
      background: rgba(255,184,0,0.1);
      border: 1px solid rgba(255,184,0,0.3);
      color: var(--warning);
    }

    .status-success {
      background: rgba(170,255,0,0.1);
      border: 1px solid rgba(170,255,0,0.3);
      color: var(--success);
    }

    /* â”€â”€ METRIC CARDS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .metric-card {
      background: var(--bg-2);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 24px;
      transition: border-color 0.2s;
    }

    .metric-card:hover { border-color: var(--border-bright); }

    .metric-label {
      font-size: 11px;
      color: var(--text-dim);
      margin-bottom: 12px;
      letter-spacing: 2px;
      text-transform: uppercase;
      font-weight: 600;
    }

    .metric-value {
      font-family: var(--font-display);
      font-size: 44px;
      letter-spacing: 1px;
      color: var(--primary);
      margin-bottom: 4px;
      line-height: 1;
    }

    /* â”€â”€ INSIGHT CARDS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .insight-card {
      padding: 20px;
      border-radius: 12px;
      display: flex;
      gap: 16px;
      margin-bottom: 10px;
      border: 1px solid var(--border);
      background: var(--bg-2);
      transition: all 0.2s;
    }

    .insight-card:hover { border-color: var(--border-bright); transform: translateX(3px); }

    .insight-icon { font-size: 28px; flex-shrink: 0; }
    .insight-content { flex: 1; }

    .insight-title {
      font-weight: 700;
      font-size: 14px;
      margin-bottom: 5px;
      color: var(--text);
      letter-spacing: 0.2px;
    }

    .insight-text { font-size: 13px; color: var(--text-dim); line-height: 1.65; }

    /* â”€â”€ PROGRESS BARS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .progress-bar {
      height: 6px;
      background: rgba(255,255,255,0.06);
      border-radius: 3px;
      overflow: hidden;
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--primary-dim) 0%, var(--primary) 100%);
      transition: width 1.2s cubic-bezier(0.22, 1, 0.36, 1);
      border-radius: 3px;
      box-shadow: 0 0 8px rgba(0,229,255,0.4);
    }

    /* â”€â”€ VIDEO â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .video-container {
      position: relative;
      margin-bottom: 24px;
      border-radius: 14px;
      overflow: hidden;
      background: #000;
      border: 1px solid var(--border);
    }

    .video-player {
      width: 100%;
      display: block;
      max-height: 600px;
    }

    .canvas-overlay {
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: none;
    }

    .processing-overlay {
      position: absolute;
      inset: 0;
      background: rgba(8,12,20,0.75);
      backdrop-filter: blur(4px);
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
    }

    .spinner {
      border: 3px solid rgba(0,229,255,0.15);
      border-top: 3px solid var(--primary);
      border-radius: 50%;
      width: 38px;
      height: 38px;
      animation: spin 0.8s linear infinite;
      margin-right: 16px;
      box-shadow: 0 0 16px rgba(0,229,255,0.3);
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.7; transform: scale(1.04); }
    }

    @keyframes slideIn {
      from { opacity: 0; transform: translateY(12px); }
      to { opacity: 1; transform: translateY(0); }
    }

    /* â”€â”€ PROFILE FORM â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .profile-form {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 16px;
      margin-bottom: 24px;
    }

    .form-group { display: flex; flex-direction: column; }

    .form-label {
      font-size: 11px;
      font-weight: 700;
      color: var(--text-dim);
      margin-bottom: 8px;
      letter-spacing: 2px;
      text-transform: uppercase;
    }

    .form-input, .form-select {
      padding: 12px 16px;
      border: 1.5px solid var(--border);
      border-radius: 10px;
      font-size: 14px;
      font-family: var(--font-body);
      outline: none;
      transition: all 0.2s;
      background: var(--bg-2);
      color: var(--text);
    }

    .form-input:focus, .form-select:focus {
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(0,229,255,0.08);
    }

    .form-select { cursor: pointer; }

    .form-select option { background: var(--bg-3); color: var(--text); }

    /* â”€â”€ BMI GAUGE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .bmi-gauge {
      position: relative;
      height: 10px;
      border-radius: 5px;
      background: linear-gradient(to right, #3B82F6 0%, #10B981 28%, #FFB800 65%, #FF3D71 100%);
      margin: 10px 0 6px;
      overflow: visible;
    }

    .bmi-needle {
      position: absolute;
      top: -5px;
      transform: translateX(-50%);
      width: 4px;
      height: 20px;
      background: white;
      border-radius: 2px;
      box-shadow: 0 0 8px rgba(255,255,255,0.6);
    }

    /* â”€â”€ DIET CARDS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .diet-card {
      background: var(--bg-2);
      border-radius: 12px;
      padding: 18px;
      border: 1px solid var(--border);
      transition: border-color 0.2s;
    }

    .diet-card:hover { border-color: var(--border-bright); }

    .diet-pill {
      display: inline-block;
      padding: 3px 12px;
      border-radius: 100px;
      font-size: 11px;
      font-weight: 700;
      white-space: nowrap;
      flex-shrink: 0;
      letter-spacing: 0.5px;
      font-family: var(--font-mono);
    }

    .pill-protein { background: rgba(59,130,246,0.15); color: #60A5FA; border: 1px solid rgba(59,130,246,0.25); }
    .pill-carb    { background: rgba(255,184,0,0.12); color: #FFB800; border: 1px solid rgba(255,184,0,0.25); }
    .pill-fat     { background: rgba(244,114,182,0.12); color: #F472B6; border: 1px solid rgba(244,114,182,0.25); }
    .pill-micro   { background: rgba(170,255,0,0.1); color: var(--success); border: 1px solid rgba(170,255,0,0.25); }

    /* â”€â”€ GRIDS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .grid-2 {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      gap: 16px;
      margin: 24px 0;
    }

    .grid-3 {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 14px;
      margin: 24px 0;
    }

    /* â”€â”€ SECTION DIVIDER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .section-divider {
      height: 1px;
      background: linear-gradient(90deg, transparent, var(--border), transparent);
      margin: 32px 0;
    }

    /* â”€â”€ INJURY CARDS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .injury-card {
      display: flex;
      gap: 16px;
      padding: 20px;
      border-radius: 14px;
      border: 1px solid var(--border);
      background: var(--bg-2);
      margin-bottom: 12px;
      transition: border-color 0.2s;
    }
    .injury-high   { border-left: 4px solid #EF4444; background: rgba(239,68,68,0.05); }
    .injury-medium { border-left: 4px solid #F59E0B; background: rgba(245,158,11,0.05); }
    .injury-low    { border-left: 4px solid #10B981; background: rgba(16,185,129,0.05); }

    /* Scrollbar */
    ::-webkit-scrollbar { width: 6px; height: 6px; }
    ::-webkit-scrollbar-track { background: var(--bg-2); }
    ::-webkit-scrollbar-thumb { background: var(--bg-3); border-radius: 3px; }
    ::-webkit-scrollbar-thumb:hover { background: var(--text-muted); }

    /* Select option dark */
    select option { background: #0E1420; }

    @media print {
      body { background: white !important; color: black !important; }
      .app-container { max-width: 100% !important; padding: 0 !important; }
      .header, .nav-tabs, .button-group, .btn, video, canvas { display: none !important; }
      .content-card { box-shadow: none !important; border: none !important; background: white !important; color: black !important; }
      .metric-card, .insight-card { background: #f5f5f5 !important; color: black !important; border: 1px solid #ddd !important; }
      .metric-value { color: #0099bb !important; }
      .metric-label, .insight-title, .insight-text, .module-title, .module-subtitle { color: black !important; }
      * { -webkit-print-color-adjust: exact; print-color-adjust: exact; }
    }

    @media (max-width: 768px) {
      .header {
        flex-direction: column;
        text-align: center;
        gap: 14px;
        padding: 16px 20px;
        position: relative;
        top: 0;
        margin-bottom: 18px;
      }
      .app-container { padding: 14px 16px; }
      .content-card { padding: 22px 18px; }
      .nav-tabs { justify-content: flex-start; }
      .grid-2, .grid-3 { grid-template-columns: 1fr; }
      .module-title { font-size: 28px; }
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useRef, useEffect } = React;

    // Enhanced sport patterns with realistic, broader ranges for better accuracy
    const SPORT_PATTERNS = {
      'long-jump': {
        name: 'Long Jump',
        emoji: 'ðŸƒâ€â™‚ï¸',
        description: 'Horizontal jumping with sprint approach',
        keyPoints: {
          ankleKneeAngle: { min: 120, max: 180, optimal: 160 },
          hipAngle: { min: 130, max: 180, optimal: 165 },
          armSwing: { min: 100, max: 180, optimal: 150 },
          speedRequirement: 3.0, // Lowered - video speed is relative
          takeoffAngle: { min: 15, max: 30, optimal: 21 }
        },
        weights: {
          form: 0.30,
          power: 0.20,
          consistency: 0.20,
          balance: 0.15,
          timing: 0.15
        }
      },
      'high-jump': {
        name: 'High Jump',
        emoji: 'ðŸ¤¸',
        description: 'Vertical jumping with curved approach',
        keyPoints: {
          ankleKneeAngle: { min: 110, max: 180, optimal: 155 },
          hipAngle: { min: 130, max: 185, optimal: 165 },
          armSwing: { min: 70, max: 180, optimal: 140 },
          speedRequirement: 2.5, // Lowered
          takeoffAngle: { min: 45, max: 75, optimal: 60 }
        },
        weights: {
          form: 0.35,
          power: 0.20,
          consistency: 0.18,
          balance: 0.12,
          timing: 0.15
        }
      },
      sprinting: {
        name: 'Sprinting',
        emoji: 'ðŸƒâ€â™€ï¸',
        description: 'Maximum velocity running',
        keyPoints: {
          ankleKneeAngle: { min: 60, max: 130, optimal: 90 },
          hipAngle: { min: 155, max: 195, optimal: 180 },
          armSwing: { min: 60, max: 130, optimal: 90 },
          speedRequirement: 3.5, // Lowered significantly
          strideFrequency: { min: 3.5, max: 5.5, optimal: 4.5 }
        },
        weights: {
          form: 0.25,
          power: 0.25,
          consistency: 0.25,
          balance: 0.10,
          timing: 0.15
        }
      },
      basketball: {
        name: 'Basketball Shooting',
        emoji: 'ðŸ€',
        description: 'Jump shot mechanics',
        keyPoints: {
          ankleKneeAngle: { min: 95, max: 160, optimal: 130 },
          hipAngle: { min: 125, max: 180, optimal: 160 },
          armSwing: { min: 70, max: 140, optimal: 100 },
          speedRequirement: 1.2, // Lowered - shooting is slower
          releaseAngle: { min: 40, max: 60, optimal: 50 }
        },
        weights: {
          form: 0.35,
          power: 0.15,
          consistency: 0.25,
          balance: 0.15,
          timing: 0.10
        }
      },
      soccer: {
        name: 'Soccer Kicking',
        emoji: 'âš½',
        description: 'Ball striking technique',
        keyPoints: {
          ankleKneeAngle: { min: 85, max: 160, optimal: 125 },
          hipAngle: { min: 115, max: 175, optimal: 150 },
          armSwing: { min: 40, max: 110, optimal: 70 },
          speedRequirement: 1.8, // Lowered
          followThrough: { min: 25, max: 55, optimal: 40 }
        },
        weights: {
          form: 0.30,
          power: 0.20,
          consistency: 0.20,
          balance: 0.15,
          timing: 0.15
        }
      },
      tennis: {
        name: 'Tennis Serve',
        emoji: 'ðŸŽ¾',
        description: 'Overhead serving motion',
        keyPoints: {
          ankleKneeAngle: { min: 110, max: 175, optimal: 145 },
          hipAngle: { min: 135, max: 190, optimal: 170 },
          armSwing: { min: 120, max: 180, optimal: 160 },
          speedRequirement: 2.0, // Lowered
          rotationAngle: { min: 40, max: 75, optimal: 60 }
        },
        weights: {
          form: 0.32,
          power: 0.18,
          consistency: 0.22,
          balance: 0.13,
          timing: 0.15
        }
      },
      running: {
        name: 'Distance Running',
        emoji: 'ðŸƒ',
        description: 'Endurance running form',
        keyPoints: {
          ankleKneeAngle: { min: 75, max: 135, optimal: 100 },
          hipAngle: { min: 155, max: 190, optimal: 175 },
          armSwing: { min: 60, max: 115, optimal: 85 },
          speedRequirement: 2.0, // Lowered significantly
          cadence: { min: 160, max: 190, optimal: 180 }
        },
        weights: {
          form: 0.30,
          power: 0.10,
          consistency: 0.35,
          balance: 0.15,
          timing: 0.10
        }
      },
      golf: {
        name: 'Golf Swing',
        emoji: 'â›³',
        description: 'Full swing mechanics',
        keyPoints: {
          ankleKneeAngle: { min: 120, max: 180, optimal: 155 },
          hipAngle: { min: 110, max: 170, optimal: 145 },
          armSwing: { min: 80, max: 160, optimal: 120 },
          speedRequirement: 0.8, // Lowered - golf is slower
          rotationAngle: { min: 70, max: 120, optimal: 95 }
        },
        weights: {
          form: 0.40,
          power: 0.15,
          consistency: 0.25,
          balance: 0.15,
          timing: 0.05
        }
      },
      yoga: {
        name: 'Yoga Poses',
        emoji: 'ðŸ§˜',
        description: 'Static pose holding',
        keyPoints: {
          ankleKneeAngle: { min: 70, max: 180, optimal: 130 },
          hipAngle: { min: 70, max: 180, optimal: 135 },
          armSwing: { min: 0, max: 180, optimal: 90 },
          speedRequirement: 0.2, // Very low for yoga
          stability: { min: 70, max: 100, optimal: 90 }
        },
        weights: {
          form: 0.40,
          power: 0.05,
          consistency: 0.25,
          balance: 0.25,
          timing: 0.05
        }
      },
      volleyball: {
        name: 'Volleyball Spike',
        emoji: 'ðŸ',
        description: 'Attack hitting motion',
        keyPoints: {
          ankleKneeAngle: { min: 95, max: 165, optimal: 135 },
          hipAngle: { min: 130, max: 180, optimal: 165 },
          armSwing: { min: 110, max: 180, optimal: 155 },
          speedRequirement: 1.5, // Lowered
          approachAngle: { min: 25, max: 55, optimal: 40 }
        },
        weights: {
          form: 0.30,
          power: 0.20,
          consistency: 0.20,
          balance: 0.15,
          timing: 0.15
        }
      },
      baseball: {
        name: 'Baseball Batting',
        emoji: 'âš¾',
        description: 'Swing mechanics',
        keyPoints: {
          ankleKneeAngle: { min: 105, max: 170, optimal: 145 },
          hipAngle: { min: 125, max: 180, optimal: 160 },
          armSwing: { min: 75, max: 155, optimal: 115 },
          speedRequirement: 1.5, // Lowered
          rotationSpeed: { min: 500, max: 900, optimal: 700 }
        },
        weights: {
          form: 0.30,
          power: 0.20,
          consistency: 0.20,
          balance: 0.15,
          timing: 0.15
        }
      },
      gymnastics: {
        name: 'Gymnastics',
        emoji: 'ðŸ¤¸â€â™€ï¸',
        description: 'Floor routine movements',
        keyPoints: {
          ankleKneeAngle: { min: 70, max: 180, optimal: 150 },
          hipAngle: { min: 70, max: 180, optimal: 160 },
          armSwing: { min: 0, max: 180, optimal: 130 },
          speedRequirement: 1.5, // Lowered
          flexibility: { min: 60, max: 100, optimal: 85 }
        },
        weights: {
          form: 0.40,
          power: 0.15,
          consistency: 0.20,
          balance: 0.15,
          timing: 0.10
        }
      }
    };

    // â”€â”€ Robust storage: tries window.storage (Claude artifact), falls back to localStorage â”€â”€
    const store = {
      get: async (key) => {
        try {
          if (window.storage) {
            const r = await window.storage.get(key);
            return r ? r.value : null;
          }
        } catch(e) {}
        try { return localStorage.getItem(key); } catch(e) { return null; }
      },
      set: async (key, val) => {
        try {
          if (window.storage) { await window.storage.set(key, val); return; }
        } catch(e) {}
        try { localStorage.setItem(key, val); } catch(e) {}
      },
      del: async (key) => {
        try {
          if (window.storage) { await window.storage.delete(key); return; }
        } catch(e) {}
        try { localStorage.removeItem(key); } catch(e) {}
      }
    };

    function SXA() {
      const [activeTab, setActiveTab] = useState('profile');
      const [videoFile, setVideoFile] = useState(null);
      const [analyzing, setAnalyzing] = useState(false);
      const [results, setResults] = useState(null);
      const [error, setError] = useState(null);
      const [progress, setProgress] = useState(0);

      const [webcamMode, setWebcamMode] = useState(false);
      const [webcamStatus, setWebcamStatus] = useState('idle');
      const [webcamCountdown, setWebcamCountdown] = useState(null);
      const [webcamSeconds, setWebcamSeconds] = useState(0);

      // Athlete profile
      const [athleteProfile, setAthleteProfile] = useState(null);
      const [profileLoaded, setProfileLoaded] = useState(false);

      // Progress tracking
      const [sessionHistory, setSessionHistory] = useState([]);
      const [historyLoaded, setHistoryLoaded] = useState(false);

      // Load profile and history on mount
      useEffect(() => {
        const loadData = async () => {
          try {
            const profileVal = await store.get('sxa:profile');
            if (profileVal) {
              const profile = JSON.parse(profileVal);
              setAthleteProfile(profile);
              setActiveTab('upload');
            }
          } catch(e) { /* no profile yet */ }
          setProfileLoaded(true);
          try {
            const sessionVal = await store.get('sxa:sessions');
            if (sessionVal) setSessionHistory(JSON.parse(sessionVal));
          } catch(e) { /* no history yet */ }
          setHistoryLoaded(true);
        };
        loadData();
      }, []);

      const [profileSaved, setProfileSaved] = useState(false);

      const saveProfile = async (profile) => {
        try {
          await store.set('sxa:profile', JSON.stringify(profile));
          setAthleteProfile(profile);
          setProfileSaved(true);
          setActiveTab('upload');
        } catch(e) { console.warn('Could not save profile:', e); }
      };
      
      const videoRef = useRef(null);
      const canvasRef = useRef(null);
      const fileInputRef = useRef(null);

      // Webcam refs
      const webcamVideoRef = useRef(null);
      const webcamCanvasRef = useRef(null);
      const webcamStreamRef = useRef(null);
      const mediaRecorderRef = useRef(null);
      const recordedChunksRef = useRef([]);
      const countdownTimerRef = useRef(null);
      const recordTimerRef = useRef(null);
      const livePoseRef = useRef(null);        // MediaPipe Pose instance for live overlay
      const liveAnimFrameRef = useRef(null);   // rAF handle for live loop

      // â”€â”€ Webcam handlers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

      const startWebcamPreview = async () => {
        setError(null);
        try {
          const stream = await navigator.mediaDevices.getUserMedia({
            video: { width: { ideal: 1280 }, height: { ideal: 720 }, facingMode: 'user' },
            audio: false
          });
          webcamStreamRef.current = stream;
          if (webcamVideoRef.current) {
            webcamVideoRef.current.srcObject = stream;
            webcamVideoRef.current.play();
          }
          setWebcamStatus('preview');

          // Start live pose skeleton overlay
          if (typeof window.Pose !== 'undefined') {
            try {
              const livePose = new window.Pose({
                locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.5.1675469404/${f}`
              });
              livePose.setOptions({ modelComplexity: 0, smoothLandmarks: true, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });

              livePose.onResults((res) => {
                const cv = webcamCanvasRef.current;
                const vid = webcamVideoRef.current;
                if (!cv || !vid) return;
                cv.width = vid.videoWidth || 640;
                cv.height = vid.videoHeight || 480;
                const ctx = cv.getContext('2d');
                ctx.clearRect(0, 0, cv.width, cv.height);
                if (res.poseLandmarks) drawSkeleton(ctx, res.poseLandmarks, cv.width, cv.height);
              });

              livePoseRef.current = livePose;

              const runLiveLoop = async () => {
                if (!webcamStreamRef.current || !webcamVideoRef.current) return;
                const vid = webcamVideoRef.current;
                if (vid.readyState >= 2) {
                  try { await livePose.send({ image: vid }); } catch(e) {}
                }
                liveAnimFrameRef.current = requestAnimationFrame(runLiveLoop);
              };
              runLiveLoop();
            } catch(e) { console.warn('Live pose init failed:', e); }
          }
        } catch (err) {
          setError({ title: 'Camera Access Denied', message: 'Please allow camera access in your browser and try again.' });
        }
      };

      // Draw MediaPipe skeleton on canvas
      const drawSkeleton = (ctx, landmarks, w, h) => {
        const CONNECTIONS = [
          [11,12],[11,13],[13,15],[12,14],[14,16],[11,23],[12,24],[23,24],
          [23,25],[25,27],[27,29],[27,31],[24,26],[26,28],[28,30],[28,32],
          [15,17],[15,19],[16,18],[16,20]
        ];
        // Lines
        ctx.strokeStyle = 'rgba(6,214,160,0.85)';
        ctx.lineWidth = 2.5;
        CONNECTIONS.forEach(([a,b]) => {
          const lA = landmarks[a], lB = landmarks[b];
          if (!lA || !lB || lA.visibility < 0.4 || lB.visibility < 0.4) return;
          ctx.beginPath();
          ctx.moveTo(lA.x * w, lA.y * h);
          ctx.lineTo(lB.x * w, lB.y * h);
          ctx.stroke();
        });
        // Joints
        landmarks.forEach((lm, i) => {
          if (lm.visibility < 0.4) return;
          ctx.beginPath();
          ctx.arc(lm.x * w, lm.y * h, i === 0 ? 5 : 4, 0, Math.PI * 2);
          ctx.fillStyle = i === 0 ? '#FBBF24' : '#06D6A0';
          ctx.fill();
        });
      };

      const stopWebcamPreview = () => {
        // Stop live skeleton loop
        if (liveAnimFrameRef.current) { cancelAnimationFrame(liveAnimFrameRef.current); liveAnimFrameRef.current = null; }
        if (livePoseRef.current) { try { livePoseRef.current.close(); } catch(e) {} livePoseRef.current = null; }
        if (webcamStreamRef.current) {
          webcamStreamRef.current.getTracks().forEach(t => t.stop());
          webcamStreamRef.current = null;
        }
        clearTimeout(countdownTimerRef.current);
        clearInterval(recordTimerRef.current);
        setWebcamStatus('idle');
        setWebcamCountdown(null);
        setWebcamSeconds(0);
        recordedChunksRef.current = [];
      };

      const startCountdownAndRecord = () => {
        setWebcamStatus('countdown');
        let count = 3;
        setWebcamCountdown(count);
        countdownTimerRef.current = setInterval(() => {
          count--;
          if (count > 0) {
            setWebcamCountdown(count);
          } else {
            clearInterval(countdownTimerRef.current);
            setWebcamCountdown(null);
            beginRecording();
          }
        }, 1000);
      };

      const beginRecording = () => {
        if (!webcamStreamRef.current) return;
        recordedChunksRef.current = [];
        const mimeType = ['video/webm;codecs=vp9', 'video/webm;codecs=vp8', 'video/webm', 'video/mp4']
          .find(t => MediaRecorder.isTypeSupported(t)) || '';
        const recorder = new MediaRecorder(webcamStreamRef.current, mimeType ? { mimeType } : {});
        mediaRecorderRef.current = recorder;
        recorder.ondataavailable = (e) => {
          if (e.data && e.data.size > 0) recordedChunksRef.current.push(e.data);
        };
        recorder.onstop = () => {
          const blob = new Blob(recordedChunksRef.current, { type: mimeType || 'video/webm' });
          const ext = mimeType.includes('mp4') ? 'mp4' : 'webm';
          const file = new File([blob], `webcam_recording.${ext}`, { type: blob.type });
          if (webcamStreamRef.current) {
            webcamStreamRef.current.getTracks().forEach(t => t.stop());
            webcamStreamRef.current = null;
          }
          setVideoFile(file);
          setResults(null);
          setError(null);
          setWebcamStatus('recorded');
          clearInterval(recordTimerRef.current);
        };
        recorder.start(100);
        setWebcamStatus('recording');
        setWebcamSeconds(0);
        let secs = 0;
        recordTimerRef.current = setInterval(() => {
          secs++;
          setWebcamSeconds(secs);
          if (secs >= 30) stopRecording();
        }, 1000);
      };

      const stopRecording = () => {
        clearInterval(recordTimerRef.current);
        if (mediaRecorderRef.current && mediaRecorderRef.current.state !== 'inactive') {
          mediaRecorderRef.current.stop();
        }
      };

      const useRecordedVideo = () => {
        setWebcamMode(false);
        setWebcamStatus('idle');
        setActiveTab('analyze');
      };

      const retakeVideo = () => {
        recordedChunksRef.current = [];
        setVideoFile(null);
        setWebcamStatus('idle');
        startWebcamPreview();
      };

      // â”€â”€ File upload handler â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

      const handleFileSelect = (event) => {
        const file = event.target.files?.[0];
        if (file) {
          // Enhanced video validation
          const validTypes = ['video/mp4', 'video/webm', 'video/quicktime', 'video/x-msvideo'];
          const maxSize = 100 * 1024 * 1024; // 100MB

          if (!validTypes.includes(file.type)) {
            setError({
              title: 'Invalid File Type',
              message: 'Please upload a video file (MP4, WebM, MOV, or AVI)'
            });
            return;
          }

          if (file.size > maxSize) {
            setError({
              title: 'File Too Large',
              message: 'Please upload a video smaller than 100MB'
            });
            return;
          }

          setVideoFile(file);
          setError(null);
          setResults(null);
          setActiveTab('analyze');
        }
      };

      const analyzeVideo = async () => {
        if (!videoFile) {
          setError({
            title: 'No Video Selected',
            message: 'Please upload a video first'
          });
          return;
        }

        setAnalyzing(true);
        setError(null);
        setProgress(0);

        try {
          // Load video
          const videoUrl = URL.createObjectURL(videoFile);
          const video = videoRef.current;
          video.src = videoUrl;

          await new Promise((resolve, reject) => {
            video.onloadedmetadata = resolve;
            video.onerror = () => reject(new Error('Failed to load video'));
            setTimeout(() => reject(new Error('Video loading timeout')), 10000);
          });

          console.log('Video loaded:', {
            duration: video.duration,
            width: video.videoWidth,
            height: video.videoHeight
          });

          // Accept any video length - we'll sample intelligently
          if (video.duration < 1) {
            throw new Error('Video is too short (min 1 second). Please upload a video showing at least 2-3 seconds of movement.');
          }

          // For very long videos, show a warning but continue
          if (video.duration > 120) {
            console.log('Warning: Long video detected. Will sample key frames throughout the video.');
          }

          const canvas = canvasRef.current;
          canvas.width = video.videoWidth;
          canvas.height = video.videoHeight;
          const ctx = canvas.getContext('2d');

          // Initialize MediaPipe Pose with error handling
          let pose;
          try {
            // Check if Pose is available
            if (typeof window.Pose === 'undefined') {
              throw new Error('MediaPipe Pose library not loaded. Please check your internet connection and refresh.');
            }
            
            pose = new window.Pose({
              locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.5.1675469404/${file}`;
              }
            });

            pose.setOptions({
              modelComplexity: 1,
              smoothLandmarks: true,
              enableSegmentation: false,
              minDetectionConfidence: 0.5,
              minTrackingConfidence: 0.5
            });
          } catch (err) {
            throw new Error('Failed to initialize pose detection. Please refresh and try again.');
          }

          let frames = [];
          let frameCount = 0;
          
          // Intelligent sampling based on video duration
          // Short videos (< 10s): Sample every frame for 90 frames max
          // Medium videos (10-30s): Sample strategically across the video
          // Long videos (> 30s): Sample from multiple segments
          const targetFrames = 90; // Always aim for 90 frames for analysis
          const videoDuration = video.duration;
          
          let samplingStrategy;
          if (videoDuration <= 10) {
            // Short video - dense sampling
            samplingStrategy = {
              maxFrames: Math.min(targetFrames, Math.floor(videoDuration * 30)),
              interval: 1,
              method: 'continuous'
            };
          } else if (videoDuration <= 30) {
            // Medium video - sample throughout
            samplingStrategy = {
              maxFrames: targetFrames,
              interval: Math.max(1, Math.floor(videoDuration * 30 / targetFrames)),
              method: 'uniform'
            };
          } else {
            // Long video - sample from beginning, middle, and end segments
            samplingStrategy = {
              maxFrames: targetFrames,
              segments: [
                { start: 0, duration: 5 }, // First 5 seconds
                { start: videoDuration / 2 - 2.5, duration: 5 }, // Middle 5 seconds
                { start: videoDuration - 5, duration: 5 } // Last 5 seconds
              ],
              method: 'segmented'
            };
          }
          
          console.log('Sampling strategy:', samplingStrategy);
          
          const maxFrames = samplingStrategy.maxFrames;
          const sampleInterval = samplingStrategy.interval || 1;
          let processingComplete = false;
          let processingTimeout;
          let currentSegmentIndex = 0;

          pose.onResults((results) => {
            if (results.poseLandmarks && !processingComplete) {
              frames.push(results.poseLandmarks);
              setProgress(Math.min(95, (frames.length / maxFrames) * 100));
            }
          });

          // Set a maximum processing timeout - scale with video duration
          const timeoutDuration = Math.min(60000, 15000 + (videoDuration * 1000)); // 15s base + video duration
          processingTimeout = setTimeout(async () => {
            if (!processingComplete) {
              video.pause();
              console.log('Processing timeout - analyzing with available frames:', frames.length);
              
              if (frames.length < 5) {
                processingComplete = true;
                setError({
                  title: 'Processing Timeout',
                  message: `Analysis took too long and only captured ${frames.length} frames. The video may be too low quality, or the person may not be visible. Please try a clearer video.`
                });
                setAnalyzing(false);
                setProgress(0);
                pose.close();
                URL.revokeObjectURL(videoUrl);
                return;
              }
              
              // Let finishProcessing set processingComplete and handle everything
              await finishProcessing();
            }
          }, timeoutDuration);

          console.log('Timeout set to:', timeoutDuration, 'ms');

          // Process video frames based on strategy
          video.currentTime = 0;
          video.play();
          
          const processFrame = async () => {
            if (processingComplete) return;
            
            // Check if we've collected enough frames
            if (frames.length >= maxFrames) {
              await finishProcessing();
              return;
            }
            
            // Handle segmented sampling for long videos
            if (samplingStrategy.method === 'segmented') {
              const segments = samplingStrategy.segments;
              
              if (currentSegmentIndex >= segments.length) {
                await finishProcessing();
                return;
              }
              
              const currentSegment = segments[currentSegmentIndex];
              const segmentEnd = currentSegment.start + currentSegment.duration;
              
              // If we're past the current segment, move to next
              if (video.currentTime >= segmentEnd) {
                currentSegmentIndex++;
                if (currentSegmentIndex < segments.length) {
                  video.currentTime = segments[currentSegmentIndex].start;
                  requestAnimationFrame(processFrame);
                  return;
                } else {
                  await finishProcessing();
                  return;
                }
              }
              
              // If we haven't reached the segment yet, seek to it
              if (video.currentTime < currentSegment.start) {
                video.currentTime = currentSegment.start;
                requestAnimationFrame(processFrame);
                return;
              }
            }
            
            // Check if we've reached the end for continuous/uniform methods
            if (samplingStrategy.method !== 'segmented' && video.currentTime >= video.duration) {
              await finishProcessing();
              return;
            }
            
            try {
              ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
              
              if (frameCount % sampleInterval === 0 || samplingStrategy.method === 'segmented') {
                await pose.send({ image: canvas });
              }
              
              frameCount++;
              requestAnimationFrame(processFrame);
            } catch (err) {
              console.error('Frame processing error:', err);
              requestAnimationFrame(processFrame); // Continue despite errors
            }
          };

          const finishProcessing = async () => {
            if (processingComplete) return;
            processingComplete = true;
            clearTimeout(processingTimeout);
            
            video.pause();
            video.currentTime = 0;
            
            console.log('Processing finished with', frames.length, 'frames');
            
            if (frames.length < 5) {
              setError({
                title: 'Insufficient Data',
                message: `Only ${frames.length} frames detected. Please ensure: 1) The person is fully visible and in frame, 2) Video quality is clear, 3) Good lighting, 4) The person is performing athletic movements.`
              });
              setAnalyzing(false);
              setProgress(0);
              pose.close();
              URL.revokeObjectURL(videoUrl);
              return;
            }

            try {
              // --- Claude AI visual validation ---
              // Capture a representative frame from the middle of the video
              setProgress(80);
              let aiSportLabel = null;
              let aiIsValid = true; // default allow; set false if AI says not a sport

              try {
                // Capture 3 frames: 25%, 50%, 75% through video for better coverage
                const snapTimes = [video.duration * 0.25, video.duration * 0.5, video.duration * 0.75];
                const snapCanvas = document.createElement('canvas');
                const scale = Math.min(1, 480 / canvas.width); // Slightly smaller per frame since we send 3
                snapCanvas.width = Math.round(canvas.width * scale);
                snapCanvas.height = Math.round(canvas.height * scale);
                const snapCtx = snapCanvas.getContext('2d');

                // Build content array with 3 images
                const contentBlocks = [];
                for (const t of snapTimes) {
                  await new Promise((res) => {
                    video.onseeked = res;   // assign BEFORE setting currentTime to avoid race
                    video.currentTime = t;
                  });
                  ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                  snapCtx.drawImage(canvas, 0, 0, snapCanvas.width, snapCanvas.height);
                  const b64 = snapCanvas.toDataURL('image/jpeg', 0.65).split(',')[1];
                  contentBlocks.push({ type: 'image', source: { type: 'base64', media_type: 'image/jpeg', data: b64 } });
                }
                video.onseeked = null; // clean up
                contentBlocks.push({
                  type: 'text',
                  text: `These are 3 frames from a video (at 25%, 50%, 75% through). Answer ONLY with a JSON object:
{"isSport": true/false, "sport": "specific sport name or null", "confidence": 0-100, "reason": "one sentence"}

isSport = true ONLY if frames show a person performing an athletic sport or exercise.
isSport = false for: sitting, casual standing, walking slowly, landscapes, non-athletic content.
sport: be specific (e.g. "basketball", "soccer", "sprinting", "tennis serve", "yoga", "gymnastics") or null.`
                });

                const aiResponse = await fetch('https://api.anthropic.com/v1/messages', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({
                    model: 'claude-sonnet-4-20250514',
                    max_tokens: 150,
                    messages: [{ role: 'user', content: contentBlocks }]
                  })
                });

                if (aiResponse.ok) {
                  const aiData = await aiResponse.json();
                  const rawText = aiData.content?.map(b => b.text || '').join('').trim();
                  console.log('Claude AI validation response:', rawText);
                  try {
                    const clean = rawText.replace(/```json|```/g, '').trim();
                    const parsed = JSON.parse(clean);
                    // Require both isSport=true AND at least 40% AI confidence
                    aiIsValid = parsed.isSport === true && (parsed.confidence === undefined || parsed.confidence >= 40);
                    aiSportLabel = parsed.sport || null;
                    console.log('AI validation:', { aiIsValid, aiSportLabel, confidence: parsed.confidence, reason: parsed.reason });
                  } catch (parseErr) {
                    console.warn('Could not parse AI response, skipping AI gate:', parseErr);
                    aiIsValid = true;
                  }
                } else {
                  console.warn('Claude AI validation request failed, skipping AI gate');
                  aiIsValid = true;
                }
              } catch (aiErr) {
                console.warn('Claude AI validation error, skipping AI gate:', aiErr);
                aiIsValid = true; // fall back to pose-only analysis
              }

              // If AI says it's not a sport, return immediately with a clear message
              if (!aiIsValid) {
                setError({
                  title: 'Not a Sport Video',
                  message: 'The uploaded video does not appear to show athletic or sports activity. Please upload a video of you performing a sport (running, jumping, basketball, soccer, tennis, etc.) with your full body visible.'
                });
                setAnalyzing(false);
                setProgress(0);
                pose.close();
                URL.revokeObjectURL(videoUrl);
                return;
              }

              setProgress(90);

              // Analyze the collected pose frames
              const analysisResults = await analyzePoseData(frames, aiSportLabel, athleteProfile);
              console.log('Analysis results:', analysisResults);
              
              setResults(analysisResults);
              setProgress(100);

              // Save session to progress history
              if (analysisResults.sport !== 'not-a-sport') {
                try {
                  const newSession = {
                    id: Date.now(),
                    date: new Date().toLocaleDateString(),
                    time: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),
                    sport: analysisResults.sport,
                    sportName: analysisResults.sportName,
                    score: analysisResults.score,
                    scores: analysisResults.scores
                  };
                  const storedVal = await store.get('sxa:sessions');
                  const prev = storedVal ? JSON.parse(storedVal) : [];
                  const updated = [...prev, newSession].slice(-20); // keep last 20
                  await store.set('sxa:sessions', JSON.stringify(updated));
                  setSessionHistory(updated);
                } catch(e) { console.warn('Could not save session history:', e); }
              }
              
              setTimeout(() => {
                setAnalyzing(false);
                setActiveTab('results');
              }, 100);
            } catch (analysisError) {
              console.error('Analysis error:', analysisError);
              setError({
                title: 'Analysis Failed',
                message: 'Failed to analyze the pose data. Please try a different video.'
              });
              setAnalyzing(false);
              setProgress(0);
            }
            
            // Clean up
            pose.close();
            URL.revokeObjectURL(videoUrl);
          };

          processFrame();

        } catch (err) {
          console.error('Analysis error:', err);
          setError({
            title: 'Analysis Failed',
            message: err.message || 'An error occurred during video analysis. Please try again with a different video.'
          });
          setAnalyzing(false);
          setProgress(0);
        }
      };

      // Enhanced pose data analysis with more accurate calculations
      const analyzePoseData = async (frames, aiSportLabel = null, profile = null) => {
        // Input validation
        if (!frames || frames.length < 5) {
          throw new Error('Insufficient frames for analysis');
        }

        const metrics = {
          ankleKneeAngles: [],   // right leg knee angle
          ankleKneeAnglesL: [],  // left leg knee angle
          hipAngles: [],         // right hip angle
          hipAnglesL: [],        // left hip angle
          armSwings: [],         // right arm elbow angle
          armSwingsL: [],        // left arm elbow angle
          torsoLean: [],         // torso forward/back lean angle
          wristSpeeds: [],       // right wrist speed (for striking/throwing sports)
          speeds: [],            // overall body speed via hip displacement
          balanceScores: [],
          timingScores: [],
          consistencyScores: []
        };

        // Calculate metrics for each frame
        frames.forEach((landmarks, index) => {
          if (!landmarks || !Array.isArray(landmarks)) return;

          // --- RIGHT leg ---
          const rAnkle = landmarks[28], rKnee = landmarks[26], rHip = landmarks[24];
          if (rAnkle && rKnee && rHip && rAnkle.visibility > 0.45 && rKnee.visibility > 0.45 && rHip.visibility > 0.45) {
            const a = calculateAngle(rAnkle, rKnee, rHip);
            if (!isNaN(a) && isFinite(a)) metrics.ankleKneeAngles.push(a);
          }

          // --- LEFT leg ---
          const lAnkle = landmarks[27], lKnee = landmarks[25], lHip = landmarks[23];
          if (lAnkle && lKnee && lHip && lAnkle.visibility > 0.45 && lKnee.visibility > 0.45 && lHip.visibility > 0.45) {
            const a = calculateAngle(lAnkle, lKnee, lHip);
            if (!isNaN(a) && isFinite(a)) metrics.ankleKneeAnglesL.push(a);
          }

          // --- Hip angles: both sides ---
          const rShoulder = landmarks[12], lShoulder = landmarks[11];
          if (rHip && rKnee && rShoulder && rHip.visibility > 0.45 && rKnee.visibility > 0.45 && rShoulder.visibility > 0.45) {
            const a = calculateAngle(rKnee, rHip, rShoulder);
            if (!isNaN(a) && isFinite(a)) metrics.hipAngles.push(a);
          }
          if (lHip && lKnee && lShoulder && lHip.visibility > 0.45 && lKnee.visibility > 0.45 && lShoulder.visibility > 0.45) {
            const a = calculateAngle(lKnee, lHip, lShoulder);
            if (!isNaN(a) && isFinite(a)) metrics.hipAnglesL.push(a);
          }

          // --- Arm angles: both sides ---
          const rWrist = landmarks[16], rElbow = landmarks[14];
          if (rWrist && rElbow && rShoulder && rWrist.visibility > 0.45 && rElbow.visibility > 0.45 && rShoulder.visibility > 0.45) {
            const a = calculateAngle(rWrist, rElbow, rShoulder);
            if (!isNaN(a) && isFinite(a)) metrics.armSwings.push(a);
          }
          const lWrist = landmarks[15], lElbow = landmarks[13];
          if (lWrist && lElbow && lShoulder && lWrist.visibility > 0.45 && lElbow.visibility > 0.45 && lShoulder.visibility > 0.45) {
            const a = calculateAngle(lWrist, lElbow, lShoulder);
            if (!isNaN(a) && isFinite(a)) metrics.armSwingsL.push(a);
          }

          // --- Torso lean: shoulder-hip vertical angle ---
          const midShoulder = rShoulder && lShoulder && rShoulder.visibility > 0.4 && lShoulder.visibility > 0.4
            ? { x: (rShoulder.x + lShoulder.x) / 2, y: (rShoulder.y + lShoulder.y) / 2 } : null;
          const midHip = rHip && lHip && rHip.visibility > 0.4 && lHip.visibility > 0.4
            ? { x: (rHip.x + lHip.x) / 2, y: (rHip.y + lHip.y) / 2 } : null;
          if (midShoulder && midHip) {
            const dx = midShoulder.x - midHip.x;
            const dy = midShoulder.y - midHip.y;
            const lean = Math.abs(Math.atan2(dx, -dy) * 180 / Math.PI); // 0 = upright
            if (!isNaN(lean) && isFinite(lean)) metrics.torsoLean.push(lean);
          }

          // --- Wrist speed (right) for striking/throwing detection ---
          if (index > 0 && rWrist && rWrist.visibility > 0.45) {
            const prevLm = frames[index - 1];
            const prevRWrist = prevLm && prevLm[16];
            if (prevRWrist && prevRWrist.visibility > 0.45) {
              const d = Math.sqrt(Math.pow(rWrist.x - prevRWrist.x, 2) + Math.pow(rWrist.y - prevRWrist.y, 2));
              const ws = d * 30 * 10;
              if (!isNaN(ws) && isFinite(ws) && ws < 200) metrics.wristSpeeds.push(ws);
            }
          }

          // --- Body speed via hip center ---
          if (index > 0 && midHip) {
            const prevLm = frames[index - 1];
            const prevRHip = prevLm && prevLm[24];
            const prevLHip = prevLm && prevLm[23];
            if (prevRHip && prevLHip && prevRHip.visibility > 0.4 && prevLHip.visibility > 0.4) {
              const prevMid = { x: (prevRHip.x + prevLHip.x) / 2, y: (prevRHip.y + prevLHip.y) / 2 };
              const d = Math.sqrt(Math.pow(midHip.x - prevMid.x, 2) + Math.pow(midHip.y - prevMid.y, 2));
              const speed = d * 30 * 10;
              if (!isNaN(speed) && isFinite(speed) && speed >= 0 && speed < 100) metrics.speeds.push(speed);
            }
          }

          // --- Balance: compare left vs right ankle height + hip centering ---
          if (lAnkle && rAnkle && lAnkle.visibility > 0.45 && rAnkle.visibility > 0.45) {
            const verticalDiff = Math.abs(lAnkle.y - rAnkle.y) * 100;
            const balance = Math.max(0, Math.min(100, 100 - verticalDiff));
            if (!isNaN(balance)) metrics.balanceScores.push(balance);
          }

          // --- Timing: smoothness of knee angle change ---
          if (index > 0 && metrics.ankleKneeAngles.length > 1) {
            const angleChange = Math.abs(
              metrics.ankleKneeAngles[metrics.ankleKneeAngles.length - 1] -
              metrics.ankleKneeAngles[metrics.ankleKneeAngles.length - 2]
            );
            const timingScore = 100 - Math.min(100, angleChange * 1.2);
            if (!isNaN(timingScore) && isFinite(timingScore)) metrics.timingScores.push(timingScore);
          }
        });

        // Merge left+right leg/arm for more robust averages
        metrics.ankleKneeAngles = [...metrics.ankleKneeAngles, ...metrics.ankleKneeAnglesL];
        metrics.hipAngles = [...metrics.hipAngles, ...metrics.hipAnglesL];
        metrics.armSwings = [...metrics.armSwings, ...metrics.armSwingsL];

        // Calculate consistency scores (lower standard deviation = higher consistency)
        const calculateConsistency = (values) => {
          if (!values || values.length < 2) return 0;
          const mean = values.reduce((a, b) => a + b, 0) / values.length;
          if (mean === 0) return 0;
          const variance = values.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / values.length;
          const stdDev = Math.sqrt(variance);
          const coefficientOfVariation = (stdDev / mean) * 100;
          return Math.max(0, Math.min(100, 100 - coefficientOfVariation));
        };

        metrics.consistencyScores = [
          calculateConsistency(metrics.ankleKneeAngles),
          calculateConsistency(metrics.hipAngles),
          calculateConsistency(metrics.armSwings)
        ].filter(score => !isNaN(score) && isFinite(score));

        // Validate sufficient data
        console.log('Raw metrics summary:', {
          ankleKneeAngles: metrics.ankleKneeAngles.length,
          hipAngles: metrics.hipAngles.length,
          armSwings: metrics.armSwings.length,
          speeds: metrics.speeds.length,
          balanceScores: metrics.balanceScores.length,
          wristSpeeds: metrics.wristSpeeds.length,
          torsoLean: metrics.torsoLean.length
        });

        if (metrics.ankleKneeAngles.length < 3 || metrics.hipAngles.length < 3) {
          throw new Error('Insufficient pose data quality. Key body parts not detected consistently. Please ensure the person is fully visible and well-lit in the video.');
        }

        // Apply smoothing
        metrics.ankleKneeAngles = smoothAndClean(metrics.ankleKneeAngles);
        metrics.hipAngles = smoothAndClean(metrics.hipAngles);
        metrics.armSwings = smoothAndClean(metrics.armSwings);
        metrics.speeds = smoothAndClean(metrics.speeds);
        metrics.balanceScores = smoothAndClean(metrics.balanceScores);
        metrics.wristSpeeds = smoothAndClean(metrics.wristSpeeds);
        metrics.torsoLean = smoothAndClean(metrics.torsoLean);

        // Compute Range of Motion (ROM) â€” max minus min for key angles
        const computeROM = (arr) => arr.length > 1 ? Math.max(...arr) - Math.min(...arr) : 0;
        metrics.kneeROM = computeROM(metrics.ankleKneeAngles);
        metrics.hipROM = computeROM(metrics.hipAngles);
        metrics.armROM = computeROM(metrics.armSwings);
        metrics.avgWristSpeed = average(metrics.wristSpeeds);
        metrics.avgTorsoLean = average(metrics.torsoLean);

        console.log('Smoothed + ROM metrics:', {
          ankleKneeAngles: metrics.ankleKneeAngles.length,
          hipAngles: metrics.hipAngles.length,
          kneeROM: metrics.kneeROM.toFixed(1),
          hipROM: metrics.hipROM.toFixed(1),
          armROM: metrics.armROM.toFixed(1),
          avgWristSpeed: metrics.avgWristSpeed.toFixed(2),
          avgTorsoLean: metrics.avgTorsoLean.toFixed(1)
        });

        // Determine sport with improved accuracy
        const sportScores = {};
        Object.keys(SPORT_PATTERNS).forEach(sport => {
          sportScores[sport] = calculateSportMatch(metrics, sport);
        });

        // If Claude AI identified a specific sport, boost that sport's score
        if (aiSportLabel) {
          const normalizedAiLabel = aiSportLabel.toLowerCase().trim();
          Object.keys(SPORT_PATTERNS).forEach(sport => {
            const sportName = SPORT_PATTERNS[sport].name.toLowerCase();
            if (sportName.includes(normalizedAiLabel) || normalizedAiLabel.includes(sport.replace('-', ' '))) {
              sportScores[sport] = Math.min(100, sportScores[sport] * 1.25 + 10); // 25% boost + 10 points
              console.log('AI label boost applied to:', sport, '->', sportScores[sport]);
            }
          });
        }

        console.log('Sport scores:', sportScores);

        const sortedSports = Object.entries(sportScores)
          .sort(([, a], [, b]) => b - a);
        
        const detectedSport = sortedSports[0][0];
        const confidence = sortedSports[0][1];

        console.log('Top sport:', detectedSport, 'Confidence:', confidence);

        // Minimal "not a sport" detection - accept almost everything
        const MIN_SPORT_CONFIDENCE = 15; // Very low - any pattern match counts
        const avgSpeed = average(metrics.speeds);
        const avgBalance = average(metrics.balanceScores);
        const avgConsistency = average(metrics.consistencyScores);
        const avgAnkleKnee = average(metrics.ankleKneeAngles);
        const avgHip = average(metrics.hipAngles);
        const avgArmSwing = average(metrics.armSwings);
        
        // Minimal checks - accept almost any movement
        const hasSignificantMovement = avgSpeed > 0.05 || metrics.speeds.length > 5; // Any movement or enough frames
        const hasBalance = avgBalance > 10 || !avgBalance; // Very lenient or skip if no data
        const hasConsistency = avgConsistency > 2 || !avgConsistency; // Almost nothing or skip if no data
        const hasAthleticAngles = avgAnkleKnee > 30 && avgAnkleKnee < 175 && avgHip > 30 && avgHip < 175; // Valid 0-180 range check
        
        // Check for variation in movement
        const speedVariation = metrics.speeds.length > 0 ? 
          Math.max(...metrics.speeds) - Math.min(...metrics.speeds) : 1; // Default to 1 if no data
        const hasMovementVariation = speedVariation > 0.05 || metrics.speeds.length > 5; // Very minimal
        
        // Accept even close matches, but require at least a minimal gap
        const secondBestConfidence = sortedSports[1] ? sortedSports[1][1] : 0;
        const confidenceGap = confidence - secondBestConfidence;
        const hasClearMatch = confidenceGap >= 3 || confidence >= 60; // Real check: need either a gap OR high confidence
        
        console.log('Detection criteria:', {
          confidence,
          MIN_SPORT_CONFIDENCE,
          avgSpeed,
          avgBalance,
          avgConsistency,
          avgAnkleKnee,
          avgHip,
          hasSignificantMovement,
          hasBalance,
          hasConsistency,
          hasAthleticAngles,
          hasMovementVariation,
          hasClearMatch,
          confidenceGap,
          ankleKneePoints: metrics.ankleKneeAngles.length,
          hipPoints: metrics.hipAngles.length,
          speedsLength: metrics.speeds.length,
          'Top 3 Sports': sortedSports.slice(0, 3).map(([sport, score]) => 
            `${SPORT_PATTERNS[sport].name}: ${Math.round(score)}%`
          )
        });
        
        // Check if this is actually a sport activity
        const isValidSport = confidence >= MIN_SPORT_CONFIDENCE && 
                            hasSignificantMovement && 
                            hasAthleticAngles &&
                            hasClearMatch &&
                            metrics.ankleKneeAngles.length > 2 &&
                            metrics.hipAngles.length > 2;
        
        // Only fail if truly no data or completely invalid
        
        console.log('Is valid sport:', isValidSport);

        if (!isValidSport) {
          // Determine specific reason for rejection
          let rejectionReason = 'The movement pattern does not match any supported sports.';
          
          if (confidence < MIN_SPORT_CONFIDENCE) {
            rejectionReason = `Low confidence score (${Math.round(confidence)}%). The movement doesn't clearly match any supported sport. Minimum ${MIN_SPORT_CONFIDENCE}% required.`;
          } else if (!hasClearMatch) {
            rejectionReason = `Ambiguous movement pattern (confidence gap: ${Math.round(confidenceGap)}%). The video shows unclear or mixed movements that don't distinctly match a single sport.`;
          } else if (!hasSignificantMovement) {
            rejectionReason = `Insufficient athletic movement (speed: ${avgSpeed.toFixed(2)}). The video appears to show casual movement rather than athletic activity. Please upload a video with clear sports movements.`;
          } else if (!hasMovementVariation) {
            rejectionReason = `Static or repetitive movement (variation: ${speedVariation.toFixed(2)}). Athletic activities require dynamic movement. Please show active sports performance.`;
          } else if (!hasBalance) {
            rejectionReason = `Poor balance detection (score: ${Math.round(avgBalance)}%). Unable to detect stable athletic posture. Ensure the person is fully visible in the frame.`;
          } else if (!hasConsistency) {
            rejectionReason = `Inconsistent movement pattern (score: ${Math.round(avgConsistency)}%). The movements are too erratic or random to match athletic technique.`;
          } else if (!hasAthleticAngles) {
            rejectionReason = `Non-athletic body positions detected. The joint angles don't match typical sports movements.`;
          } else if (metrics.ankleKneeAngles.length <= 2) {
            rejectionReason = `Not enough pose data captured (${metrics.ankleKneeAngles.length} frames). The person may not be clearly visible throughout the video.`;
          }
          
          return {
            sport: 'not-a-sport',
            sportName: 'Not a Sport',
            score: 0,
            scores: { form: 0, power: 0, consistency: 0, balance: 0, timing: 0 },
            insights: [
              {
                icon: 'âŒ',
                severity: 'high',
                category: 'Not Recognized',
                message: rejectionReason
              },
              {
                icon: 'ðŸŽ¥',
                severity: 'medium',
                category: 'Video Requirements',
                message: 'For best results: 1) Show clear, dynamic athletic movements, 2) Keep the full body visible, 3) Use good lighting, 4) Keep camera stable, 5) Capture actual sports performance (not warm-ups or casual movement).'
              },
              {
                icon: 'ðŸ’¡',
                severity: 'low',
                category: 'What Qualifies as a Sport',
                message: 'Upload videos showing: explosive jumps, sprint running, shooting (basketball), kicking (soccer), serving (tennis/volleyball), swinging (golf/baseball), or other athletic movements with clear technique and power.'
              }
            ],
            alternatives: null,
            frameCount: frames.length,
            confidence: Math.round(confidence),
            detectionDetails: {
              confidenceScore: Math.round(confidence),
              hasSignificantMovement,
              hasBalance,
              hasConsistency,
              hasAthleticAngles,
              hasMovementVariation,
              hasClearMatch,
              confidenceGap: Math.round(confidenceGap),
              dataPoints: metrics.ankleKneeAngles.length,
              topMatch: SPORT_PATTERNS[detectedSport].name,
              topMatchScore: Math.round(confidence),
              secondMatch: sortedSports[1] ? SPORT_PATTERNS[sortedSports[1][0]].name : 'N/A',
              secondMatchScore: Math.round(secondBestConfidence),
              avgSpeed: avgSpeed.toFixed(2),
              speedVariation: speedVariation.toFixed(2)
            },
            metrics: {
              avgAnkleKneeAngle: Math.round(average(metrics.ankleKneeAngles)),
              avgHipAngle: Math.round(average(metrics.hipAngles)),
              avgArmSwing: Math.round(average(metrics.armSwings)),
              avgSpeed: average(metrics.speeds).toFixed(1),
              consistency: Math.round(average(metrics.consistencyScores)),
              balance: Math.round(average(metrics.balanceScores)),
              timing: Math.round(average(metrics.timingScores))
            }
          };
        }

        // Get alternative sports (if confidence is not very high)
        const alternatives = sortedSports
          .slice(1, 4)
          .filter(([, score]) => score > 50)
          .map(([sport, score]) => ({
            sport,
            confidence: Math.round(score)
          }));

        // Calculate detailed scores
        const pattern = SPORT_PATTERNS[detectedSport];
        const scores = calculateDetailedScores(metrics, detectedSport);

        // AI-powered personalized insights
        const insights = await generateInsights(scores, detectedSport, metrics, profile);

        return {
          sport: detectedSport,
          sportName: pattern.name,
          score: Math.round(confidence),
          scores,
          insights,
          alternatives: alternatives.length > 0 ? alternatives : null,
          frameCount: frames.length,
          metrics: {
            avgAnkleKneeAngle: Math.round(average(metrics.ankleKneeAngles)),
            avgHipAngle: Math.round(average(metrics.hipAngles)),
            avgArmSwing: Math.round(average(metrics.armSwings)),
            avgSpeed: average(metrics.speeds).toFixed(1),
            kneeROM: Math.round(metrics.kneeROM || 0),
            hipROM: Math.round(metrics.hipROM || 0),
            armROM: Math.round(metrics.armROM || 0),
            avgWristSpeed: (metrics.avgWristSpeed || 0).toFixed(1),
            avgTorsoLean: Math.round(metrics.avgTorsoLean || 0),
            consistency: Math.round(average(metrics.consistencyScores)),
            balance: Math.round(average(metrics.balanceScores)),
            timing: Math.round(average(metrics.timingScores))
          }
        };
      };

      // Helper function to calculate angle between three points
      // Helper function to calculate angle between three points (improved)
      const calculateAngle = (a, b, c) => {
        // Validate inputs
        if (!a || !b || !c) return NaN;
        if (typeof a.x !== 'number' || typeof a.y !== 'number') return NaN;
        if (typeof b.x !== 'number' || typeof b.y !== 'number') return NaN;
        if (typeof c.x !== 'number' || typeof c.y !== 'number') return NaN;

        // Calculate 2D angle (primary)
        const radians = Math.atan2(c.y - b.y, c.x - b.x) - 
                       Math.atan2(a.y - b.y, a.x - b.x);
        let angle = Math.abs(radians * 180.0 / Math.PI);
        if (angle > 180.0) angle = 360 - angle;
        
        // Clamp to valid range
        return Math.max(0, Math.min(180, angle));
      };

      // Helper function to calculate average with validation
      const average = (arr) => {
        if (!arr || arr.length === 0) return 0;
        const validValues = arr.filter(val => !isNaN(val) && isFinite(val));
        if (validValues.length === 0) return 0;
        return validValues.reduce((a, b) => a + b, 0) / validValues.length;
      };

      // Helper function to smooth data and remove outliers
      const smoothAndClean = (arr) => {
        if (!arr || arr.length < 3) return arr;
        
        // Remove outliers using IQR method
        const sorted = [...arr].sort((a, b) => a - b);
        const q1 = sorted[Math.floor(sorted.length * 0.25)];
        const q3 = sorted[Math.floor(sorted.length * 0.75)];
        const iqr = q3 - q1;
        const lowerBound = q1 - 1.5 * iqr;
        const upperBound = q3 + 1.5 * iqr;
        
        const cleaned = arr.filter(val => val >= lowerBound && val <= upperBound);
        
        // Apply simple moving average smoothing
        if (cleaned.length < 3) return cleaned;
        
        const smoothed = [];
        for (let i = 0; i < cleaned.length; i++) {
          if (i === 0) {
            smoothed.push((cleaned[0] + cleaned[1]) / 2);
          } else if (i === cleaned.length - 1) {
            smoothed.push((cleaned[i - 1] + cleaned[i]) / 2);
          } else {
            smoothed.push((cleaned[i - 1] + cleaned[i] + cleaned[i + 1]) / 3);
          }
        }
        
        return smoothed;
      };

      // Calculate how well metrics match a specific sport
      const calculateSportMatch = (metrics, sportKey) => {
        const pattern = SPORT_PATTERNS[sportKey];
        const keyPoints = pattern.keyPoints;
        const weights = pattern.weights;
        
        let totalScore = 0;
        let totalWeight = 0;

        // Ankle-knee angle match - very generous scoring
        const avgAnkleKnee = average(metrics.ankleKneeAngles);
        if (avgAnkleKnee > 0 && avgAnkleKnee >= keyPoints.ankleKneeAngle.min && 
            avgAnkleKnee <= keyPoints.ankleKneeAngle.max) {
          const deviation = Math.abs(avgAnkleKnee - keyPoints.ankleKneeAngle.optimal);
          const range = keyPoints.ankleKneeAngle.max - keyPoints.ankleKneeAngle.min;
          const score = Math.max(60, 100 - (deviation / range) * 50); // High base score, low penalty
          totalScore += score * weights.form * 1.2;
          totalWeight += weights.form * 1.2;
        } else if (avgAnkleKnee > 0) {
          // Even if outside range, give substantial credit
          const closestBound = avgAnkleKnee < keyPoints.ankleKneeAngle.min ? 
            keyPoints.ankleKneeAngle.min : keyPoints.ankleKneeAngle.max;
          const deviation = Math.abs(avgAnkleKnee - closestBound);
          const partialScore = Math.max(40, 70 - deviation * 0.3); // High partial credit
          totalScore += partialScore * weights.form * 0.8;
          totalWeight += weights.form * 0.8;
        }

        // Hip angle match - very generous
        const avgHip = average(metrics.hipAngles);
        if (avgHip > 0 && avgHip >= keyPoints.hipAngle.min && avgHip <= keyPoints.hipAngle.max) {
          const deviation = Math.abs(avgHip - keyPoints.hipAngle.optimal);
          const range = keyPoints.hipAngle.max - keyPoints.hipAngle.min;
          const score = Math.max(60, 100 - (deviation / range) * 50); // High base score, low penalty
          totalScore += score * weights.form * 1.2;
          totalWeight += weights.form * 1.2;
        } else if (avgHip > 0) {
          const closestBound = avgHip < keyPoints.hipAngle.min ? 
            keyPoints.hipAngle.min : keyPoints.hipAngle.max;
          const deviation = Math.abs(avgHip - closestBound);
          const partialScore = Math.max(40, 70 - deviation * 0.3); // High partial credit
          totalScore += partialScore * weights.form * 0.8;
          totalWeight += weights.form * 0.8;
        }

        // Arm swing match - very generous
        const avgArm = average(metrics.armSwings);
        if (avgArm > 0 && avgArm >= keyPoints.armSwing.min && avgArm <= keyPoints.armSwing.max) {
          const deviation = Math.abs(avgArm - keyPoints.armSwing.optimal);
          const range = keyPoints.armSwing.max - keyPoints.armSwing.min;
          const score = Math.max(60, 100 - (deviation / range) * 50); // High base score, low penalty
          totalScore += score * weights.form * 0.8;
          totalWeight += weights.form * 0.8;
        } else if (avgArm > 0) {
          const closestBound = avgArm < keyPoints.armSwing.min ? 
            keyPoints.armSwing.min : keyPoints.armSwing.max;
          const deviation = Math.abs(avgArm - closestBound);
          const partialScore = Math.max(40, 70 - deviation * 0.3); // High partial credit
          totalScore += partialScore * weights.form * 0.5;
          totalWeight += weights.form * 0.5;
        }

        // Speed match - extremely forgiving and realistic
        const avgSpeed = average(metrics.speeds);
        if (avgSpeed > 0) {
          const speedRatio = avgSpeed / keyPoints.speedRequirement;
          let speedScore;
          
          // Accept almost any speed with good scores
          if (speedRatio < 0.15) {
            speedScore = Math.max(50, speedRatio * 300); // Give decent score even for very slow
          } else if (speedRatio >= 0.15 && speedRatio <= 5.0) {
            // Very wide optimal range - almost everything scores well
            speedScore = Math.min(100, 60 + speedRatio * 10);
          } else {
            speedScore = Math.max(65, 110 - speedRatio * 8); // Still good score for very fast
          }
          
          totalScore += Math.max(0, speedScore) * weights.power * 1.5;
          totalWeight += weights.power * 1.5;
        }

        // Consistency bonus - always add something
        const avgConsistency = average(metrics.consistencyScores);
        if (avgConsistency > 0) {
          totalScore += avgConsistency * weights.consistency * 1.2;
          totalWeight += weights.consistency * 1.2;
        } else {
          totalScore += 70 * weights.consistency;
          totalWeight += weights.consistency;
        }

        // Balance bonus - always add something
        const avgBalance = average(metrics.balanceScores);
        if (avgBalance > 0) {
          totalScore += avgBalance * weights.balance * 1.2;
          totalWeight += weights.balance * 1.2;
        } else {
          totalScore += 70 * weights.balance;
          totalWeight += weights.balance;
        }

        // --- ROM signal: sports with large ROM (jumps, kicks) vs small ROM (golf, yoga) ---
        if (metrics.kneeROM !== undefined && metrics.kneeROM > 0) {
          // High-ROM sports: sprinting (90Â°+), soccer, basketball, gymnastics
          // Low-ROM sports: golf, yoga (steady positions)
          const romExpectation = {
            'long-jump': 60, 'high-jump': 70, sprinting: 80, basketball: 50,
            soccer: 60, tennis: 40, running: 55, golf: 25, yoga: 30,
            volleyball: 55, baseball: 45, gymnastics: 65
          };
          const expectedROM = romExpectation[sportKey] || 40;
          const romDiff = Math.abs(metrics.kneeROM - expectedROM);
          const romScore = Math.max(40, 100 - romDiff * 0.8);
          totalScore += romScore * 0.08;
          totalWeight += 0.08;
        }

        // --- Wrist speed signal: high for striking/throwing, low for running/yoga ---
        if (metrics.avgWristSpeed !== undefined && metrics.avgWristSpeed > 0) {
          const wristExpectation = {
            'long-jump': 0.5, 'high-jump': 0.8, sprinting: 0.6, basketball: 1.2,
            soccer: 0.4, tennis: 2.0, running: 0.5, golf: 1.8, yoga: 0.1,
            volleyball: 2.2, baseball: 2.5, gymnastics: 1.0
          };
          const expectedWrist = wristExpectation[sportKey] || 0.8;
          const wristRatio = metrics.avgWristSpeed / (expectedWrist + 0.1);
          const wristScore = wristRatio >= 0.5 && wristRatio <= 3.0
            ? Math.min(100, 60 + (1 - Math.abs(1 - wristRatio)) * 40)
            : Math.max(30, 60 - Math.abs(1 - wristRatio) * 20);
          totalScore += wristScore * 0.07;
          totalWeight += 0.07;
        }

        // --- Torso lean signal: forward lean for running/sprinting, upright for yoga/golf ---
        if (metrics.avgTorsoLean !== undefined && metrics.avgTorsoLean > 0) {
          const leanExpectation = {
            'long-jump': 25, 'high-jump': 15, sprinting: 20, basketball: 10,
            soccer: 15, tennis: 12, running: 12, golf: 8, yoga: 5,
            volleyball: 10, baseball: 10, gymnastics: 15
          };
          const expectedLean = leanExpectation[sportKey] || 12;
          const leanDiff = Math.abs(metrics.avgTorsoLean - expectedLean);
          const leanScore = Math.max(40, 100 - leanDiff * 1.2);
          totalScore += leanScore * 0.05;
          totalWeight += 0.05;
        }

        return totalWeight > 0 ? Math.min(100, totalScore / totalWeight) : 0;
      };

      // Calculate detailed scores for each category
      const calculateDetailedScores = (metrics, sportKey) => {
        const pattern = SPORT_PATTERNS[sportKey];
        const weights = pattern.weights;
        const keyPoints = pattern.keyPoints;

        // Form score (based on angle accuracy) - more generous calculation
        const avgAnkleKnee = average(metrics.ankleKneeAngles);
        const avgHip = average(metrics.hipAngles);
        const avgArm = average(metrics.armSwings);
        
        // Calculate normalized scores with partial credit
        const ankleRange = keyPoints.ankleKneeAngle.max - keyPoints.ankleKneeAngle.min;
        const hipRange = keyPoints.hipAngle.max - keyPoints.hipAngle.min;
        const armRange = keyPoints.armSwing.max - keyPoints.armSwing.min;
        
        // Give credit even if outside range, with high base scores
        const calculateAngleScore = (angle, min, max, optimal, range) => {
          if (angle <= 0) return 50; // Give 50 points even for missing data
          
          if (angle >= min && angle <= max) {
            // Within range - generous scoring
            const deviation = Math.abs(angle - optimal);
            return Math.max(65, 100 - (deviation / range * 40)); // High base, low penalty
          } else {
            // Outside range - still give good partial credit
            const closestBound = angle < min ? min : max;
            const deviation = Math.abs(angle - closestBound);
            return Math.max(50, 65 - deviation * 0.25); // High partial credit
          }
        };
        
        const ankleScore = calculateAngleScore(avgAnkleKnee, 
          keyPoints.ankleKneeAngle.min, keyPoints.ankleKneeAngle.max, 
          keyPoints.ankleKneeAngle.optimal, ankleRange);
        const hipScore = calculateAngleScore(avgHip, 
          keyPoints.hipAngle.min, keyPoints.hipAngle.max, 
          keyPoints.hipAngle.optimal, hipRange);
        const armScore = calculateAngleScore(avgArm, 
          keyPoints.armSwing.min, keyPoints.armSwing.max, 
          keyPoints.armSwing.optimal, armRange);
        
        const formScore = (ankleScore * 0.4 + hipScore * 0.4 + armScore * 0.2);

        // Power score - extremely forgiving
        const avgSpeed = average(metrics.speeds);
        const speedRatio = avgSpeed / keyPoints.speedRequirement;
        let powerScore;
        
        // Give high scores for almost any speed
        if (speedRatio < 0.1) {
          powerScore = Math.max(55, speedRatio * 400); // Good base score
        } else if (speedRatio >= 0.1 && speedRatio <= 4.0) {
          // Very wide optimal range - high scores across the board
          powerScore = Math.min(100, 55 + speedRatio * 12);
        } else if (speedRatio > 4.0 && speedRatio <= 6.0) {
          powerScore = 100 - (speedRatio - 4.0) * 5; // Very gentle penalty
        } else {
          powerScore = Math.max(70, 90 - (speedRatio - 6.0) * 8); // Still high score
        }

        // Consistency score - significant boost
        const rawConsistency = average(metrics.consistencyScores);
        const consistencyScore = Math.min(100, rawConsistency * 1.4 + 10); // 40% boost + 10 point bonus

        // Balance score - significant boost
        const rawBalance = average(metrics.balanceScores);
        const balanceScore = Math.min(100, rawBalance * 1.3 + 10); // 30% boost + 10 point bonus

        // Timing score - significant boost
        const rawTiming = average(metrics.timingScores);
        const timingScore = Math.min(100, rawTiming * 1.4 + 10); // 40% boost + 10 point bonus

        return {
          form: Math.max(0, Math.min(100, Math.round(formScore))),
          power: Math.max(0, Math.min(100, Math.round(powerScore))),
          consistency: Math.max(0, Math.min(100, Math.round(consistencyScore))),
          balance: Math.max(0, Math.min(100, Math.round(balanceScore))),
          timing: Math.max(0, Math.min(100, Math.round(timingScore)))
        };
      };

      // Generate AI-powered personalized insights via Claude API
      const generateInsights = async (scores, sportKey, metrics, profile = null) => {
        const pattern = SPORT_PATTERNS[sportKey];
        const avgKnee = Math.round(average(metrics.ankleKneeAngles));
        const avgHip = Math.round(average(metrics.hipAngles));
        const avgArm = Math.round(average(metrics.armSwings));
        const kneeROM = Math.round(metrics.kneeROM || 0);
        const hipROM = Math.round(metrics.hipROM || 0);
        const avgSpeed = average(metrics.speeds).toFixed(2);
        const avgWrist = (metrics.avgWristSpeed || 0).toFixed(2);
        const avgLean = Math.round(metrics.avgTorsoLean || 0);
        const avgBalance = Math.round(average(metrics.balanceScores));
        const profileStr = profile ? `Athlete: ${profile.name || 'unknown'}, Age: ${profile.age || 'unknown'}, Experience: ${profile.experienceLevel || 'unknown'}, Goals: ${(profile.goals||[]).join(', ') || 'improve performance'}, Known injuries: ${profile.preExistingInjuries || 'none'}` : '';

        // Build a concise prompt for Claude
        const prompt = `You are an elite sports performance coach analyzing an athlete's ${pattern.name} technique.
${profileStr ? '\nATHLETE PROFILE:\n' + profileStr : ''}
Pose analysis data:
- Knee angle avg: ${avgKnee}Â° (ROM: ${kneeROM}Â°)
- Hip angle avg: ${avgHip}Â° (ROM: ${hipROM}Â°)  
- Arm angle avg: ${avgArm}Â°
- Body speed index: ${avgSpeed}
- Wrist speed index: ${avgWrist}
- Torso lean: ${avgLean}Â°
- Balance score: ${avgBalance}/100
- Form: ${scores.form}/100 | Power: ${scores.power}/100 | Consistency: ${scores.consistency}/100 | Balance: ${scores.balance}/100 | Timing: ${scores.timing}/100

Return ONLY a JSON array of exactly 4 insights, no other text:
[
  {"icon": "emoji", "severity": "high|medium|low", "category": "Category Name", "message": "Specific, actionable coaching tip (2 sentences) referencing the actual numbers above."},
  ...
]

Rules:
- Each message must be specific to the numbers (e.g. "Your knee angle of ${avgKnee}Â° suggests...")
- Prioritize the lowest-scoring categories
- One insight must be positive/encouraging
- Be direct and practical like a real coach`; 

        try {
          const res = await fetch('https://api.anthropic.com/v1/messages', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              model: 'claude-sonnet-4-20250514',
              max_tokens: 600,
              messages: [{ role: 'user', content: prompt }]
            })
          });

          if (res.ok) {
            const data = await res.json();
            const raw = data.content?.map(b => b.text || '').join('').trim();
            const clean = raw.replace(/```json|```/g, '').trim();
            const parsed = JSON.parse(clean);
            if (Array.isArray(parsed) && parsed.length > 0) return parsed;
          }
        } catch (err) {
          console.warn('AI insights failed, using fallback:', err);
        }

        // Fallback static insights if API fails
        const insights = [];
        const weakest = Object.entries(scores).sort(([,a],[,b]) => a - b)[0];
        insights.push({ icon: 'âš ï¸', severity: 'high', category: weakest[0].charAt(0).toUpperCase()+weakest[0].slice(1),
          message: `Your ${weakest[0]} score of ${weakest[1]}/100 is your main area for improvement in ${pattern.name}. Focus on targeted drills to address this.` });
        insights.push({ icon: 'ðŸ“', severity: 'medium', category: 'Body Angles',
          message: `Knee angle avg ${avgKnee}Â°, hip angle avg ${avgHip}Â°. Work on aligning these closer to ideal positions for ${pattern.name} technique.` });
        insights.push({ icon: 'âš–ï¸', severity: 'medium', category: 'Balance',
          message: `Balance score: ${avgBalance}/100. ${avgBalance < 70 ? 'Add single-leg stability drills to your warmup.' : 'Solid base â€” maintain this through fatigue.'}` });
        const best = Object.entries(scores).sort(([,a],[,b]) => b - a)[0];
        insights.push({ icon: 'âœ…', severity: 'low', category: 'Strength',
          message: `Your ${best[0]} score of ${best[1]}/100 is your strongest area. Build on this foundation to elevate your overall performance.` });
        return insights;
      };

      return (
        <div className="app-container">
          <div className="header">
            <div>
              <div className="logo">SXA</div>
              <div className="tagline">AI-Powered Performance Analysis</div>
            </div>
            {athleteProfile?.name ? (
              <div style={{display:'flex', alignItems:'center', gap:'12px'}}>
                <div style={{textAlign:'right'}}>
                  <div style={{fontWeight:'700', fontSize:'14px', color:'var(--text)'}}>ðŸ‘¤ {athleteProfile.name}</div>
                  <div style={{fontSize:'11px', color:'var(--text-dim)', marginTop:'2px', fontFamily:'var(--font-mono)'}}>
                    {athleteProfile.age && `AGE ${athleteProfile.age}`}
                    {athleteProfile.primarySport ? ` Â· ${athleteProfile.primarySport.toUpperCase()}` : ''}
                  </div>
                </div>
                <button onClick={() => setActiveTab('profile')} style={{background:'rgba(0,229,255,0.08)', border:'1px solid var(--border-bright)', color:'var(--primary)', borderRadius:'8px', padding:'6px 14px', fontSize:'12px', cursor:'pointer', fontWeight:'600', fontFamily:'var(--font-body)'}}>
                  Edit
                </button>
              </div>
            ) : (
              <div className="header-badge">
                <div className="header-badge-dot"></div>
                <span className="header-badge-text">AI ACTIVE</span>
              </div>
            )}
          </div>

          <div className="nav-tabs">
            <button
              className={`nav-tab ${activeTab === 'profile' ? 'active' : ''}`}
              onClick={() => { setWebcamMode(false); setActiveTab('profile'); }}
            >
              ðŸ‘¤ Profile
            </button>
            <button
              className={`nav-tab ${activeTab === 'upload' && !webcamMode ? 'active' : ''}`}
              onClick={() => { setWebcamMode(false); setActiveTab('upload'); }}
            >
              ðŸ“¤ Upload
            </button>
            <button
              className={`nav-tab ${webcamMode ? 'active' : ''}`}
              onClick={() => { setWebcamMode(true); setActiveTab('upload'); }}
            >
              ðŸ“· Webcam
            </button>
            <button
              className={`nav-tab ${activeTab === 'live' ? 'active' : ''}`}
              onClick={() => { setWebcamMode(false); setActiveTab('live'); }}
            >
              ðŸ”´ Live Detection
            </button>
            <button
              className={`nav-tab ${activeTab === 'analyze' ? 'active' : ''}`}
              onClick={() => setActiveTab('analyze')}
              disabled={!videoFile}
            >
              ðŸ” Analyze
            </button>
            <button
              className={`nav-tab ${activeTab === 'results' ? 'active' : ''}`}
              onClick={() => setActiveTab('results')}
              disabled={!results}
            >
              ðŸ“Š Results
            </button>
            <button
              className={`nav-tab ${activeTab === 'training' ? 'active' : ''}`}
              onClick={() => setActiveTab('training')}
              disabled={!results}
            >
              ðŸŽ¯ Training
            </button>
            <button
              className={`nav-tab ${activeTab === 'injury' ? 'active' : ''}`}
              onClick={() => setActiveTab('injury')}
              disabled={!results}
            >
              ðŸ©º Injury Check
            </button>
            <button
              className={`nav-tab ${activeTab === 'diet' ? 'active' : ''}`}
              onClick={() => setActiveTab('diet')}
            >
              ðŸ¥— Diet
            </button>
            <button
              className={`nav-tab ${activeTab === 'progress' ? 'active' : ''}`}
              onClick={() => setActiveTab('progress')}
            >
              ðŸ“ˆ Progress
            </button>
          </div>

          <div className="content-card">
            {error && (
              <div className="error-message">
                <div className="error-icon">âš ï¸</div>
                <div className="error-title">{error.title}</div>
                <div className="error-text">{error.message}</div>
              </div>
            )}

            {activeTab === 'profile' && (
              <ProfileModule
                profile={athleteProfile || {
                  name: '', age: '', gender: 'male', height: '', heightUnit: 'cm',
                  weight: '', weightUnit: 'kg', experienceLevel: 'intermediate',
                  primarySport: '', weeklyTraining: '3-4', goals: [], preExistingInjuries: '',
                  dietType: 'balanced'
                }}
                onSave={saveProfile}
              />
            )}

            {activeTab === 'upload' && !webcamMode && (
              <UploadModule 
                onFileSelect={handleFileSelect} 
                videoFile={videoFile}
                fileInputRef={fileInputRef}
              />
            )}

            {activeTab === 'upload' && webcamMode && (
              <WebcamModule
                webcamVideoRef={webcamVideoRef}
                webcamCanvasRef={webcamCanvasRef}
                webcamStatus={webcamStatus}
                webcamCountdown={webcamCountdown}
                webcamSeconds={webcamSeconds}
                videoFile={videoFile}
                onStartPreview={startWebcamPreview}
                onStop={stopWebcamPreview}
                onStartCountdown={startCountdownAndRecord}
                onStopRecording={stopRecording}
                onUseVideo={useRecordedVideo}
                onRetake={retakeVideo}
              />
            )}

            {activeTab === 'analyze' && (
              <AnalyzeModule
                videoRef={videoRef}
                canvasRef={canvasRef}
                analyzing={analyzing}
                progress={progress}
                onAnalyze={analyzeVideo}
                videoFile={videoFile}
              />
            )}

            {activeTab === 'results' && results && (
              <ResultsModule results={results} />
            )}
            
            {/* Debug fallback - show if results exist but tab didn't switch */}
            {results && activeTab !== 'results' && activeTab !== 'training' && activeTab !== 'injury' && activeTab !== 'diet' && activeTab !== 'profile' && activeTab !== 'progress' && activeTab !== 'upload' && activeTab !== 'analyze' && activeTab !== 'live' && (
              <div style={{
                marginTop: '20px',
                padding: '16px',
                background: 'rgba(255,184,0,0.07)', border: '1px solid rgba(255,184,0,0.2)',
                borderRadius: '12px',
                textAlign: 'center'
              }}>
                <p style={{ marginBottom: '12px' }}>âœ… Analysis complete! Click the "Results" tab above to view your performance report.</p>
                <button 
                  className="btn btn-primary"
                  onClick={() => setActiveTab('results')}
                  style={{ marginTop: '8px' }}
                >
                  View Results
                </button>
              </div>
            )}

            {activeTab === 'training' && results && (
              <TrainingModule results={results} />
            )}

            {activeTab === 'injury' && results && (
              <InjuryModule results={results} profile={athleteProfile} />
            )}

            {activeTab === 'diet' && (
              <DietModule key={athleteProfile?.dietType || 'none'} results={results} profile={athleteProfile} />
            )}

            {activeTab === 'live' && (
              <LiveDetectionModule athleteProfile={athleteProfile} />
            )}

            {activeTab === 'progress' && (
              <ProgressModule history={sessionHistory} onClear={async () => {
                try { await store.del('sxa:sessions'); } catch(e) {}
                setSessionHistory([]);
              }} />
            )}
          </div>
        </div>
      );
    }

    // Profile Module
    function ProfileModule({ profile, onSave }) {
      const { useState: useLocalState, useEffect: useLocalEffect } = React;

      const DEFAULT_PROFILE = {
        name: '', age: '', gender: 'male', height: '', heightUnit: 'cm',
        weight: '', weightUnit: 'kg', experienceLevel: 'intermediate',
        primarySport: '', weeklyTraining: '3-4', goals: [], preExistingInjuries: '',
        dietType: 'balanced'
      };

      const [form, setForm] = useLocalState({ ...DEFAULT_PROFILE, ...profile });
      const [saved, setSaved] = useLocalState(false);

      // Re-sync form when profile loads asynchronously from storage
      useLocalEffect(() => {
        if (profile && Object.keys(profile).some(k => profile[k])) {
          setForm({ ...DEFAULT_PROFILE, ...profile });
        }
      }, [JSON.stringify(profile)]);

      const goals = ['Lose weight', 'Build muscle', 'Improve endurance', 'Increase speed', 'Flexibility', 'Competition prep', 'Injury recovery', 'General fitness'];

      const toggleGoal = (g) => {
        const cur = form.goals || [];
        setForm({ ...form, goals: cur.includes(g) ? cur.filter(x => x !== g) : [...cur, g] });
      };

      const [saving, setSaving] = useLocalState(false);

      const handleSave = async () => {
        setSaving(true);
        await onSave(form);
        setSaving(false);
        setSaved(true);
        setTimeout(() => setSaved(false), 3000);
      };

      // Calculate BMI if possible
      let bmi = null, bmiLabel = '', bmiPct = 0;
      if (form.height && form.weight) {
        let hm = parseFloat(form.height);
        let wkg = parseFloat(form.weight);
        if (form.heightUnit === 'ft') hm = hm * 30.48 / 100;
        else hm = hm / 100;
        if (form.weightUnit === 'lbs') wkg = wkg * 0.453592;
        if (hm > 0 && wkg > 0) {
          bmi = (wkg / (hm * hm)).toFixed(1);
          if (bmi < 18.5) { bmiLabel = 'Underweight'; bmiPct = (bmi / 40) * 100; }
          else if (bmi < 25) { bmiLabel = 'Normal'; bmiPct = 30 + ((bmi - 18.5) / 6.5) * 30; }
          else if (bmi < 30) { bmiLabel = 'Overweight'; bmiPct = 60 + ((bmi - 25) / 5) * 20; }
          else { bmiLabel = 'Obese'; bmiPct = Math.min(95, 80 + ((bmi - 30) / 10) * 15); }
        }
      }

      return (
        <div>
          <h2 className="module-title">ðŸ‘¤ Athlete Profile</h2>
          <p className="module-subtitle">Tell us about yourself for personalized coaching, diet plans, and injury risk analysis</p>

          <div className="profile-form">
            <div className="form-group">
              <label className="form-label">Full Name</label>
              <input className="form-input" placeholder="Your name" value={form.name || ''} onChange={e => setForm({...form, name: e.target.value})} />
            </div>
            <div className="form-group">
              <label className="form-label">Age</label>
              <input className="form-input" type="number" placeholder="e.g. 25" min="10" max="100" value={form.age || ''} onChange={e => setForm({...form, age: e.target.value})} />
            </div>
            <div className="form-group">
              <label className="form-label">Gender</label>
              <select className="form-select" value={form.gender || 'male'} onChange={e => setForm({...form, gender: e.target.value})}>
                <option value="male">Male</option>
                <option value="female">Female</option>
                <option value="other">Other / Prefer not to say</option>
              </select>
            </div>
          </div>

          <div className="profile-form">
            <div className="form-group">
              <label className="form-label">Height</label>
              <div style={{display:'flex', gap:'8px'}}>
                <input className="form-input" style={{flex:1}} type="number" placeholder={form.heightUnit === 'cm' ? '170' : '5.8'} value={form.height || ''} onChange={e => setForm({...form, height: e.target.value})} />
                <select className="form-select" style={{width:'80px'}} value={form.heightUnit || 'cm'} onChange={e => setForm({...form, heightUnit: e.target.value})}>
                  <option value="cm">cm</option>
                  <option value="ft">ft</option>
                </select>
              </div>
            </div>
            <div className="form-group">
              <label className="form-label">Weight</label>
              <div style={{display:'flex', gap:'8px'}}>
                <input className="form-input" style={{flex:1}} type="number" placeholder={form.weightUnit === 'kg' ? '70' : '154'} value={form.weight || ''} onChange={e => setForm({...form, weight: e.target.value})} />
                <select className="form-select" style={{width:'80px'}} value={form.weightUnit || 'kg'} onChange={e => setForm({...form, weightUnit: e.target.value})}>
                  <option value="kg">kg</option>
                  <option value="lbs">lbs</option>
                </select>
              </div>
            </div>
            <div className="form-group">
              <label className="form-label">Experience Level</label>
              <select className="form-select" value={form.experienceLevel || 'intermediate'} onChange={e => setForm({...form, experienceLevel: e.target.value})}>
                <option value="beginner">Beginner (0â€“1 yr)</option>
                <option value="intermediate">Intermediate (1â€“3 yrs)</option>
                <option value="advanced">Advanced (3â€“7 yrs)</option>
                <option value="elite">Elite / Professional</option>
              </select>
            </div>
          </div>

          <div className="profile-form">
            <div className="form-group">
              <label className="form-label">Primary Sport / Activity</label>
              <input className="form-input" placeholder="e.g. Running, Basketball, Tennis..." value={form.primarySport || ''} onChange={e => setForm({...form, primarySport: e.target.value})} />
            </div>
            <div className="form-group">
              <label className="form-label">Weekly Training Days</label>
              <select className="form-select" value={form.weeklyTraining || '3-4'} onChange={e => setForm({...form, weeklyTraining: e.target.value})}>
                <option value="1-2">1â€“2 days</option>
                <option value="3-4">3â€“4 days</option>
                <option value="5-6">5â€“6 days</option>
                <option value="7">Every day</option>
              </select>
            </div>
            <div className="form-group">
              <label className="form-label">Diet Preference</label>
              <select className="form-select" value={form.dietType || 'balanced'} onChange={e => setForm({...form, dietType: e.target.value})}>
                <option value="balanced">Balanced / Omnivore</option>
                <option value="vegetarian">Vegetarian</option>
                <option value="vegan">Vegan</option>
                <option value="keto">Keto / Low-carb</option>
                <option value="paleo">Paleo</option>
                <option value="mediterranean">Mediterranean</option>
              </select>
            </div>
          </div>

          <div style={{marginBottom:'24px'}}>
            <div className="form-label" style={{marginBottom:'12px'}}>ðŸŽ¯ Training Goals (select all that apply)</div>
            <div style={{display:'flex', flexWrap:'wrap', gap:'10px'}}>
              {goals.map(g => (
                <button key={g} onClick={() => toggleGoal(g)} style={{
                  padding:'8px 18px', borderRadius:'20px', fontSize:'13px', fontWeight:'600', cursor:'pointer',
                  border: (form.goals||[]).includes(g) ? '1.5px solid var(--primary)' : '1.5px solid rgba(255,255,255,0.2)',
                  background: (form.goals||[]).includes(g) ? 'linear-gradient(135deg,rgba(0,229,255,0.18),rgba(0,180,200,0.10))' : 'rgba(255,255,255,0.06)',
                  color: (form.goals||[]).includes(g) ? 'var(--primary)' : 'var(--text)',
                  boxShadow: (form.goals||[]).includes(g) ? '0 0 10px rgba(0,229,255,0.2)' : 'none',
                  transition: 'all 0.2s'
                }}>
                  {g}
                </button>
              ))}
            </div>
          </div>

          <div className="form-group" style={{marginBottom:'24px'}}>
            <label className="form-label">ðŸ©¹ Pre-existing Injuries or Conditions</label>
            <textarea className="form-input" rows={3} placeholder="e.g. Left knee pain, lower back tightness, shoulder impingement... (or leave blank)" value={form.preExistingInjuries || ''} onChange={e => setForm({...form, preExistingInjuries: e.target.value})} style={{resize:'vertical'}} />
          </div>

          {/* BMI Display */}
          {bmi && (
            <div style={{background:'var(--bg-light)', borderRadius:'14px', padding:'20px', marginBottom:'24px'}}>
              <div style={{display:'flex', justifyContent:'space-between', alignItems:'center', marginBottom:'8px'}}>
                <span style={{fontWeight:'700', fontSize:'16px'}}>ðŸ“Š Body Mass Index (BMI)</span>
                <span style={{fontWeight:'900', fontSize:'28px', color: bmi < 18.5 ? '#3B82F6' : bmi < 25 ? '#10B981' : bmi < 30 ? '#F59E0B' : '#EF4444'}}>{bmi}</span>
              </div>
              <div className="bmi-gauge">
                <div className="bmi-needle" style={{left: `${Math.min(95, Math.max(5, bmiPct))}%`}} />
              </div>
              <div style={{display:'flex', justifyContent:'space-between', fontSize:'11px', color:'var(--text-dim)', marginTop:'4px'}}>
                <span>Underweight</span><span>Normal</span><span>Overweight</span><span>Obese</span>
              </div>
              <div style={{marginTop:'10px', fontWeight:'600', color:'var(--text)'}}>Category: <span style={{color: bmi < 18.5 ? '#3B82F6' : bmi < 25 ? '#10B981' : bmi < 30 ? '#F59E0B' : '#EF4444'}}>{bmiLabel}</span></div>
            </div>
          )}

          <div className="button-group">
            <button className="btn btn-primary" onClick={handleSave} disabled={saving} style={{opacity: saving ? 0.7 : 1, minWidth: '200px'}}>
              {saving ? 'â³ Saving...' : saved ? 'âœ… Profile Saved!' : 'ðŸ’¾ Save & Continue'}
            </button>
          </div>

          {saved && (
            <div style={{marginTop:'16px', padding:'14px 20px', background:'rgba(170,255,0,0.08)', border:'1px solid rgba(170,255,0,0.3)', borderRadius:'12px', display:'flex', alignItems:'center', gap:'10px'}}>
              <span style={{fontSize:'20px'}}>âœ…</span>
              <div>
                <div style={{fontWeight:'700', color:'var(--success)', fontSize:'14px'}}>Profile saved successfully!</div>
                <div style={{fontSize:'12px', color:'var(--text-dim)', marginTop:'2px'}}>Your diet preference ({form.dietType || 'balanced'}) will be used to generate your nutrition plan.</div>
              </div>
            </div>
          )}
        </div>
      );
    }

    // Injury Detection Module
    function InjuryModule({ results, profile }) {
      const { useState: useLocalState } = React;
      const [injuries, setInjuries] = useLocalState(null);
      const [loading, setLoading] = useLocalState(false);

      const analyzeInjuryRisk = async () => {
        setLoading(true);
        const metrics = results ? results.metrics : null;
        const scores = results ? results.scores : null;
        const sport = results ? results.sportName : 'general training';

        const profileStr = profile && (profile.age || profile.preExistingInjuries) ?
          `Athlete: ${profile.age ? 'Age ' + profile.age : ''} ${profile.gender || ''}, experience: ${profile.experienceLevel || 'unknown'}, pre-existing: "${profile.preExistingInjuries || 'none'}".` : '';

        const metricsStr = metrics ? `
Pose metrics:
- Knee angle avg: ${metrics.avgAnkleKneeAngle}Â° (ROM: ${metrics.kneeROM}Â°)
- Hip angle avg: ${metrics.avgHipAngle}Â° (ROM: ${metrics.hipROM}Â°)
- Arm angle avg: ${metrics.avgArmSwing}Â°
- Torso lean: ${metrics.avgTorsoLean}Â°
- Balance: ${metrics.balance}/100
- Form: ${scores?.form}/100 | Consistency: ${scores?.consistency}/100` : '';

        const prompt = `You are a sports medicine expert and injury prevention specialist. Analyze injury risk for an athlete performing ${sport}. ${profileStr} ${metricsStr}

Return ONLY a JSON array of 4-6 injury risk items, no other text:
[
  {
    "bodyPart": "Body part name (e.g. Left Knee, Lower Back)",
    "risk": "high|medium|low",
    "riskLabel": "High Risk|Moderate Risk|Low Risk",
    "mechanism": "Brief biomechanical reason why (1 sentence)",
    "prevention": "Specific prevention exercise or technique cue (1-2 sentences)",
    "icon": "relevant emoji"
  }
]

Base your analysis on:
- The pose metrics (abnormal angles, asymmetries, poor balance)
- The sport's typical injury patterns
- The athlete's profile (age, fitness level, pre-existing issues)
- Be specific and actionable, not generic`;

        try {
          const res = await fetch('https://api.anthropic.com/v1/messages', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              model: 'claude-sonnet-4-20250514',
              max_tokens: 900,
              messages: [{ role: 'user', content: prompt }]
            })
          });
          if (res.ok) {
            const data = await res.json();
            const raw = data.content?.map(b => b.text || '').join('').trim();
            const clean = raw.replace(/```json|```/g, '').trim();
            const parsed = JSON.parse(clean);
            if (Array.isArray(parsed)) { setInjuries(parsed); setLoading(false); return; }
          }
        } catch(e) { console.warn('Injury API failed:', e); }

        // Fallback static injury analysis
        const fallback = [
          { bodyPart: 'Knee Joint', risk: 'medium', riskLabel: 'Moderate Risk', mechanism: 'Repetitive loading during athletic movements can cause patellofemoral stress.', prevention: 'Strengthen quadriceps and hamstrings with squats and Nordic curls. Focus on landing mechanics.', icon: 'ðŸ¦µ' },
          { bodyPart: 'Lower Back', risk: results?.metrics?.avgTorsoLean > 20 ? 'high' : 'low', riskLabel: results?.metrics?.avgTorsoLean > 20 ? 'High Risk' : 'Low Risk', mechanism: 'Excessive forward torso lean places compressive stress on lumbar vertebrae.', prevention: 'Engage core throughout movement. Practice hip hinge patterns with neutral spine.', icon: 'ðŸ”™' },
          { bodyPart: 'Ankle', risk: 'low', riskLabel: 'Low Risk', mechanism: 'Dynamic lateral movements can stress the ankle ligaments if landing mechanics are poor.', prevention: 'Single-leg balance training and ankle strengthening exercises reduce sprain risk significantly.', icon: 'ðŸ¦¶' },
          { bodyPart: 'Shoulder', risk: 'low', riskLabel: 'Low Risk', mechanism: 'Overhead and rotational sports stress rotator cuff tendons with repetitive use.', prevention: 'Rotator cuff strengthening with resistance bands 3x per week. Scapular stability work.', icon: 'ðŸ’ª' },
        ];
        setInjuries(fallback);
        setLoading(false);
      };

      return (
        <div>
          <h2 className="module-title">ðŸ©º Injury Risk Detection</h2>
          <p className="module-subtitle">AI-powered biomechanical injury risk assessment based on your movement patterns and profile</p>

          {profile?.preExistingInjuries && (
            <div style={{background:'#FFF7ED', border:'2px solid #F97316', borderRadius:'12px', padding:'16px', marginBottom:'20px'}}>
              <div style={{fontWeight:'700', marginBottom:'4px'}}>âš ï¸ Pre-existing Conditions Noted</div>
              <div style={{color:'var(--text)', fontSize:'14px'}}>{profile.preExistingInjuries}</div>
              <div style={{color:'var(--text-dim)', fontSize:'12px', marginTop:'6px'}}>These have been factored into your risk assessment below.</div>
            </div>
          )}

          {!injuries && !loading && (
            <div style={{textAlign:'center', padding:'40px 20px'}}>
              <div style={{fontSize:'64px', marginBottom:'16px'}}>ðŸ©»</div>
              <h3 style={{fontSize:'20px', fontWeight:'700', marginBottom:'8px'}}>Ready to assess your injury risk</h3>
              <p style={{color:'var(--text-dim)', marginBottom:'24px', maxWidth:'400px', margin:'0 auto 24px'}}>
                {results ? 'Your video has been analyzed. Click below to get a personalized injury risk report.' : 'Upload and analyze a video first for movement-specific risk, or get a general assessment based on your profile.'}
              </p>
              <button className="btn btn-primary" onClick={analyzeInjuryRisk}>
                ðŸ” Run Injury Risk Assessment
              </button>
            </div>
          )}

          {loading && (
            <div style={{textAlign:'center', padding:'48px'}}>
              <div className="spinner" style={{margin:'0 auto 16px'}} />
              <p style={{color:'var(--text-dim)'}}>Analyzing biomechanical risk factors...</p>
            </div>
          )}

          {injuries && !loading && (
            <div>
              <div style={{display:'flex', justifyContent:'space-between', alignItems:'center', marginBottom:'20px', flexWrap:'wrap', gap:'10px'}}>
                <div style={{display:'flex', gap:'12px', flexWrap:'wrap'}}>
                  {[['high','#EF4444','High Risk'], ['medium','#F59E0B','Moderate'], ['low','#10B981','Low Risk']].map(([r, c, l]) => (
                    <span key={r} style={{display:'flex', alignItems:'center', gap:'6px', fontSize:'13px', fontWeight:'600'}}>
                      <span style={{width:'12px', height:'12px', borderRadius:'50%', background:c, display:'inline-block'}} />{l}: {injuries.filter(i=>i.risk===r).length}
                    </span>
                  ))}
                </div>
                <button className="btn btn-secondary" style={{padding:'8px 16px', fontSize:'13px'}} onClick={() => { setInjuries(null); }}>
                  ðŸ”„ Re-analyze
                </button>
              </div>

              {['high','medium','low'].map(riskLevel => {
                const items = injuries.filter(i => i.risk === riskLevel);
                if (!items.length) return null;
                return items.map((item, idx) => (
                  <div key={`${riskLevel}-${idx}`} className={`injury-card injury-${riskLevel}`}>
                    <div style={{fontSize:'36px', flexShrink:0}}>{item.icon}</div>
                    <div style={{flex:1}}>
                      <div style={{display:'flex', justifyContent:'space-between', alignItems:'flex-start', flexWrap:'wrap', gap:'8px', marginBottom:'8px'}}>
                        <div style={{fontWeight:'800', fontSize:'17px'}}>{item.bodyPart}</div>
                        <span style={{
                          padding:'4px 12px', borderRadius:'20px', fontSize:'12px', fontWeight:'700',
                          background: riskLevel === 'high' ? '#EF4444' : riskLevel === 'medium' ? '#F59E0B' : '#10B981',
                          color: 'white'
                        }}>{item.riskLabel}</span>
                      </div>
                      <div style={{fontSize:'14px', color:'var(--text)', marginBottom:'8px', lineHeight:'1.5'}}>
                        <strong>Why:</strong> {item.mechanism}
                      </div>
                      <div style={{fontSize:'14px', color:'var(--text)', lineHeight:'1.5', background:'var(--bg-3)', borderRadius:'8px', padding:'10px'}}>
                        <strong>ðŸ›¡ï¸ Prevention:</strong> {item.prevention}
                      </div>
                    </div>
                  </div>
                ));
              })}

              <div style={{background:'var(--bg-3)', borderRadius:'12px', padding:'20px', marginTop:'16px', borderLeft:'3px solid var(--primary)'}}>
                <div style={{fontWeight:'700', marginBottom:'6px'}}>âš•ï¸ Important Disclaimer</div>
                <div style={{color:'var(--text-dim)', fontSize:'13px', lineHeight:'1.6'}}>
                  This AI analysis is for educational purposes only and does not constitute medical advice. Always consult a qualified sports medicine professional, physiotherapist, or doctor before starting a new exercise program or if you experience pain.
                </div>
              </div>
            </div>
          )}
        </div>
      );
    }

    // Diet & Nutrition Module
    function DietModule({ results, profile }) {
      const { useState: useLocalState } = React;
      const [plan, setPlan] = useLocalState(null);
      const [loading, setLoading] = useLocalState(false);

      // Calculate caloric needs
      const calcCalories = () => {
        if (!profile?.weight || !profile?.height || !profile?.age) return null;
        let wkg = parseFloat(profile.weight);
        let hcm = parseFloat(profile.height);
        if (profile.weightUnit === 'lbs') wkg *= 0.453592;
        if (profile.heightUnit === 'ft') hcm *= 30.48;
        const age = parseFloat(profile.age);
        if (!wkg || !hcm || !age) return null;
        // Mifflin-St Jeor BMR
        let bmr = profile.gender === 'female'
          ? (10 * wkg) + (6.25 * hcm) - (5 * age) - 161
          : (10 * wkg) + (6.25 * hcm) - (5 * age) + 5;
        const activityMulti = { '1-2': 1.375, '3-4': 1.55, '5-6': 1.725, '7': 1.9 };
        const tdee = Math.round(bmr * (activityMulti[profile.weeklyTraining] || 1.55));
        return { bmr: Math.round(bmr), tdee };
      };

      const getDietLabel = () => {
        const map = { balanced: 'Balanced / Omnivore', vegetarian: 'Vegetarian ðŸ¥¦', vegan: 'Vegan ðŸŒ±', keto: 'Keto / Low-carb ðŸ¥‘', paleo: 'Paleo ðŸ¥©', mediterranean: 'Mediterranean ðŸ«’' };
        return map[profile?.dietType] || 'Balanced / Omnivore';
      };

      const getDietRestrictions = () => {
        const dt = profile?.dietType || 'balanced';
        if (dt === 'vegetarian') return 'STRICT VEGETARIAN â€” NO meat, NO fish, NO seafood, NO chicken. Allowed: eggs, dairy, plant proteins, legumes.';
        if (dt === 'vegan') return 'STRICT VEGAN â€” NO meat, NO fish, NO dairy, NO eggs, NO whey protein, NO honey. Only 100% plant-based foods and plant protein powders.';
        if (dt === 'keto') return 'KETOGENIC â€” Very low carb (under 50g total carbs/day), high fat, moderate protein. NO grains, NO sugar, NO starchy vegetables, NO fruit except berries in small amounts.';
        if (dt === 'paleo') return 'PALEO â€” NO grains, NO legumes, NO dairy, NO processed foods, NO refined sugar. Focus on meat, fish, vegetables, fruits, nuts, and seeds.';
        if (dt === 'mediterranean') return 'MEDITERRANEAN â€” Emphasize olive oil, fish/seafood 2-3x/week, abundant vegetables, legumes, whole grains, nuts, and fruits. Limit red meat to 1-2x/week.';
        return 'BALANCED OMNIVORE â€” Include lean meats, fish, dairy, eggs, legumes, whole grains, vegetables, and fruits for optimal variety.';
      };

      const generateDietPlan = async () => {
        setLoading(true);
        const cal = calcCalories();
        const sport = results ? results.sportName : profile?.primarySport || 'general fitness';
        const goals = (profile?.goals || []).join(', ') || 'general fitness';
        const dietRestrictions = getDietRestrictions();

        const prompt = `You are a sports nutritionist. Create a personalized nutrition plan for an athlete.

CRITICAL DIETARY REQUIREMENT â€” FOLLOW THIS STRICTLY FOR EVERY FOOD ITEM:
${dietRestrictions}
Every single food item in meals, nutrient sources, and supplements MUST strictly comply with this diet type. Any violation is unacceptable.

Athlete Profile: Age ${profile?.age||'unknown'}, ${profile?.gender||'unknown'}, weight ${profile?.weight||'?'}${profile?.weightUnit||'kg'}, height ${profile?.height||'?'}${profile?.heightUnit||'cm'}, experience: ${profile?.experienceLevel||'unknown'}.
Sport/Activity: ${sport}. Training: ${profile?.weeklyTraining||'3-4'} days/week.
Goals: ${goals}.
${cal ? `Estimated TDEE: ${cal.tdee} kcal/day.` : ''}

Return ONLY a JSON object, no other text:
{
  "dailyCalories": number,
  "macros": { "protein": {"grams": number, "calories": number, "percent": number}, "carbs": {"grams": number, "calories": number, "percent": number}, "fat": {"grams": number, "calories": number, "percent": number} },
  "meals": [
    {"name": "Breakfast", "time": "7:00 AM", "calories": number, "description": "Specific meal example (2 sentences)", "foods": ["food1", "food2", "food3"]},
    {"name": "Pre-Workout Snack", "time": "11:00 AM", "calories": number, "description": "...", "foods": [...]},
    {"name": "Lunch", "time": "1:00 PM", "calories": number, "description": "...", "foods": [...]},
    {"name": "Post-Workout", "time": "4:00 PM", "calories": number, "description": "...", "foods": [...]},
    {"name": "Dinner", "time": "7:00 PM", "calories": number, "description": "...", "foods": [...]},
    {"name": "Evening Snack", "time": "9:00 PM", "calories": number, "description": "...", "foods": [...]}
  ],
  "keyNutrients": [
    {"name": "Nutrient name", "importance": "Why important for this athlete (1 sentence)", "sources": "Top 3 food sources", "type": "protein|carb|fat|micro"}
  ],
  "hydration": "Daily water recommendation with sports-specific guidance (2 sentences)",
  "supplementSuggestions": ["supplement1 - brief reason", "supplement2 - brief reason", "supplement3 - brief reason"],
  "tip": "One key personalized nutrition tip for this athlete (1-2 sentences)"
}`;

        try {
          const res = await fetch('https://api.anthropic.com/v1/messages', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              model: 'claude-sonnet-4-20250514',
              max_tokens: 1500,
              messages: [{ role: 'user', content: prompt }]
            })
          });
          if (res.ok) {
            const data = await res.json();
            const raw = data.content?.map(b => b.text || '').join('').trim();
            const clean = raw.replace(/```json|```/g, '').trim();
            const parsed = JSON.parse(clean);
            if (parsed && parsed.dailyCalories) { setPlan(parsed); setLoading(false); return; }
          }
        } catch(e) { console.warn('Diet API failed:', e); }

        // Diet-aware fallback plan
        const cal2 = calcCalories();
        const tdee = cal2?.tdee || 2200;
        const dt = profile?.dietType || 'balanced';

        const fallbackMeals = {
          vegan: [
            { name: 'Breakfast', time: '7:00 AM', calories: Math.round(tdee * 0.25), description: 'High-protein plant-based start to fuel morning activity and muscle repair.', foods: ['Tofu scramble (150g)', 'Oats (80g)', 'Banana', 'Almond milk'] },
            { name: 'Pre-Workout', time: '11:00 AM', calories: Math.round(tdee * 0.10), description: 'Quick-digesting carbs and plant protein for energy.', foods: ['Rice cakes', 'Peanut butter', 'Medjool dates'] },
            { name: 'Lunch', time: '1:00 PM', calories: Math.round(tdee * 0.25), description: 'Protein-rich legume bowl with complex carbs for sustained energy.', foods: ['Chickpeas (150g)', 'Brown rice (80g)', 'Roasted vegetables', 'Tahini dressing'] },
            { name: 'Post-Workout', time: '4:00 PM', calories: Math.round(tdee * 0.15), description: 'Plant protein shake with fast carbs to maximize the recovery window.', foods: ['Pea protein shake (30g)', 'White rice (60g)', 'Banana'] },
            { name: 'Dinner', time: '7:00 PM', calories: Math.round(tdee * 0.20), description: 'Nutrient-dense lentil meal packed with iron and plant protein.', foods: ['Red lentils (150g)', 'Sweet potato', 'Steamed broccoli', 'Quinoa (70g)'] },
            { name: 'Evening Snack', time: '9:00 PM', calories: Math.round(tdee * 0.05), description: 'Slow-digesting plant protein to support overnight recovery.', foods: ['Soy yogurt', 'Mixed nuts', 'Berries'] }
          ],
          vegetarian: [
            { name: 'Breakfast', time: '7:00 AM', calories: Math.round(tdee * 0.25), description: 'Egg-based high-protein breakfast to kickstart muscle repair.', foods: ['Eggs (3 whole)', 'Oats (80g)', 'Banana', 'Greek yogurt (150g)'] },
            { name: 'Pre-Workout', time: '11:00 AM', calories: Math.round(tdee * 0.10), description: 'Light carbs and protein for energy before training.', foods: ['Rice cakes', 'Peanut butter', 'Apple'] },
            { name: 'Lunch', time: '1:00 PM', calories: Math.round(tdee * 0.25), description: 'Cottage cheese and grain bowl for balanced macros.', foods: ['Cottage cheese (150g)', 'Brown rice (80g)', 'Mixed vegetables', 'Olive oil'] },
            { name: 'Post-Workout', time: '4:00 PM', calories: Math.round(tdee * 0.15), description: 'Whey protein and carbs to maximize the anabolic window.', foods: ['Whey protein shake (30g)', 'White rice (60g)', 'Banana'] },
            { name: 'Dinner', time: '7:00 PM', calories: Math.round(tdee * 0.20), description: 'Paneer stir-fry with complex carbs and vegetables.', foods: ['Paneer (180g)', 'Sweet potato', 'Broccoli', 'Quinoa (70g)'] },
            { name: 'Evening Snack', time: '9:00 PM', calories: Math.round(tdee * 0.05), description: 'Casein-rich snack for overnight muscle recovery.', foods: ['Cottage cheese', 'Mixed nuts', 'Berries'] }
          ],
          keto: [
            { name: 'Breakfast', time: '7:00 AM', calories: Math.round(tdee * 0.25), description: 'High-fat, zero-carb breakfast to maintain ketosis and fuel energy.', foods: ['Eggs (3 whole)', 'Bacon (3 strips)', 'Avocado (Â½)', 'Butter-cooked spinach'] },
            { name: 'Pre-Workout', time: '11:00 AM', calories: Math.round(tdee * 0.10), description: 'Fat-based snack for sustained energy without spiking blood sugar.', foods: ['Almonds (30g)', 'Cheese cubes', 'Celery with cream cheese'] },
            { name: 'Lunch', time: '1:00 PM', calories: Math.round(tdee * 0.25), description: 'Fatty fish with low-carb greens for omega-3 and protein.', foods: ['Salmon (150g)', 'Leafy green salad', 'Olive oil dressing', 'Walnuts'] },
            { name: 'Post-Workout', time: '4:00 PM', calories: Math.round(tdee * 0.15), description: 'Protein and fat combo to aid recovery without breaking ketosis.', foods: ['Chicken thighs (150g)', 'Avocado', 'Pumpkin seeds'] },
            { name: 'Dinner', time: '7:00 PM', calories: Math.round(tdee * 0.20), description: 'Beef steak with healthy fat sides for overnight muscle repair.', foods: ['Beef steak (200g)', 'Asparagus with butter', 'Cauliflower mash', 'MCT oil (1 tbsp)'] },
            { name: 'Evening Snack', time: '9:00 PM', calories: Math.round(tdee * 0.05), description: 'Low-carb, high-fat snack to keep you in ketosis overnight.', foods: ['Macadamia nuts', 'Cheese slice', 'Pepperoni'] }
          ],
          paleo: [
            { name: 'Breakfast', time: '7:00 AM', calories: Math.round(tdee * 0.25), description: 'Protein-rich paleo breakfast with healthy fats and natural sugars.', foods: ['Eggs (3 whole)', 'Sweet potato hash', 'Avocado', 'Mixed berries'] },
            { name: 'Pre-Workout', time: '11:00 AM', calories: Math.round(tdee * 0.10), description: 'Natural energy from fruit and nuts before training.', foods: ['Banana', 'Almonds (25g)', 'Dates (2)'] },
            { name: 'Lunch', time: '1:00 PM', calories: Math.round(tdee * 0.25), description: 'Lean protein with abundant vegetables for micronutrient density.', foods: ['Chicken breast (150g)', 'Roasted root vegetables', 'Arugula salad', 'Olive oil'] },
            { name: 'Post-Workout', time: '4:00 PM', calories: Math.round(tdee * 0.15), description: 'Natural protein and carbs to replenish glycogen post-workout.', foods: ['Turkey slices (100g)', 'Sweet potato (medium)', 'Coconut water'] },
            { name: 'Dinner', time: '7:00 PM', calories: Math.round(tdee * 0.20), description: 'Fatty fish packed with omega-3s and paleo-friendly sides.', foods: ['Salmon fillet (200g)', 'Roasted broccoli', 'Cauliflower rice', 'Ghee'] },
            { name: 'Evening Snack', time: '9:00 PM', calories: Math.round(tdee * 0.05), description: 'Light paleo snack to curb hunger without processed foods.', foods: ['Hard-boiled eggs (2)', 'Pumpkin seeds', 'Apple slices'] }
          ],
          mediterranean: [
            { name: 'Breakfast', time: '7:00 AM', calories: Math.round(tdee * 0.25), description: 'Mediterranean-style breakfast with whole grains and healthy fats.', foods: ['Greek yogurt (200g)', 'Whole grain toast', 'Olive oil drizzle', 'Mixed berries'] },
            { name: 'Pre-Workout', time: '11:00 AM', calories: Math.round(tdee * 0.10), description: 'Hummus and fruit for a natural carb and protein boost.', foods: ['Hummus (60g)', 'Wholegrain pita', 'Cucumber slices'] },
            { name: 'Lunch', time: '1:00 PM', calories: Math.round(tdee * 0.25), description: 'Classic Mediterranean protein bowl with legumes and grains.', foods: ['Grilled fish (140g)', 'Farro (80g)', 'Roasted peppers', 'Feta (30g)', 'Olive oil'] },
            { name: 'Post-Workout', time: '4:00 PM', calories: Math.round(tdee * 0.15), description: 'Quick protein and carb combo for rapid post-exercise recovery.', foods: ['Greek yogurt (150g)', 'Honey (1 tsp)', 'Banana', 'Walnuts'] },
            { name: 'Dinner', time: '7:00 PM', calories: Math.round(tdee * 0.20), description: 'Omega-3-rich seafood dinner with legumes and colorful vegetables.', foods: ['Grilled sardines / tuna (180g)', 'Chickpea salad', 'Whole grain bread', 'Extra virgin olive oil'] },
            { name: 'Evening Snack', time: '9:00 PM', calories: Math.round(tdee * 0.05), description: 'Light Mediterranean snack to wind down the evening.', foods: ['Handful of mixed nuts', 'Dates (2)', 'Chamomile tea'] }
          ],
          balanced: [
            { name: 'Breakfast', time: '7:00 AM', calories: Math.round(tdee * 0.25), description: 'High-protein start to fuel morning activity and support muscle repair.', foods: ['Eggs (3 whole)', 'Oats (80g)', 'Banana', 'Greek yogurt'] },
            { name: 'Pre-Workout', time: '11:00 AM', calories: Math.round(tdee * 0.10), description: 'Quick-digesting carbs for energy.', foods: ['Rice cakes', 'Peanut butter', 'Fruit'] },
            { name: 'Lunch', time: '1:00 PM', calories: Math.round(tdee * 0.25), description: 'Balanced macros to maintain energy levels throughout the day.', foods: ['Chicken breast (150g)', 'Brown rice (80g)', 'Mixed vegetables', 'Olive oil'] },
            { name: 'Post-Workout', time: '4:00 PM', calories: Math.round(tdee * 0.15), description: 'Fast protein and carbs to maximize recovery window.', foods: ['Whey protein shake', 'White rice (60g)', 'Banana'] },
            { name: 'Dinner', time: '7:00 PM', calories: Math.round(tdee * 0.20), description: 'Nutrient-dense meal with quality protein and vegetables.', foods: ['Salmon (180g)', 'Sweet potato', 'Broccoli', 'Quinoa'] },
            { name: 'Evening Snack', time: '9:00 PM', calories: Math.round(tdee * 0.05), description: 'Casein protein for overnight muscle repair.', foods: ['Cottage cheese', 'Mixed nuts', 'Berries'] }
          ]
        };

        const fallbackNutrients = {
          vegan: [
            { name: 'Plant Protein', importance: 'Essential for muscle repair â€” combine legumes and grains for complete amino acids.', sources: 'Lentils, tofu, pea protein, edamame', type: 'protein' },
            { name: 'Complex Carbohydrates', importance: 'Primary fuel source for athletic performance.', sources: 'Oats, quinoa, sweet potato, brown rice', type: 'carb' },
            { name: 'Omega-3 (ALA)', importance: 'Reduces inflammation â€” convert ALA to DHA/EPA via algae oil.', sources: 'Flaxseed, chia seeds, walnuts, algae oil', type: 'fat' },
            { name: 'Vitamin B12', importance: 'Critical for energy metabolism â€” only found naturally in animal foods.', sources: 'Fortified plant milks, nutritional yeast, B12 supplement', type: 'micro' },
          ],
          vegetarian: [
            { name: 'Protein', importance: 'Essential for muscle repair and growth after training.', sources: 'Eggs, Greek yogurt, cottage cheese, paneer, whey', type: 'protein' },
            { name: 'Complex Carbohydrates', importance: 'Primary fuel source for high-intensity performance.', sources: 'Oats, brown rice, sweet potato, whole wheat', type: 'carb' },
            { name: 'Calcium', importance: 'Supports bone density and muscle contraction during exercise.', sources: 'Milk, Greek yogurt, paneer, fortified plant milk', type: 'micro' },
            { name: 'Iron', importance: 'Carries oxygen to muscles â€” plant iron needs vitamin C to absorb.', sources: 'Lentils, spinach, fortified cereals, eggs', type: 'micro' },
          ],
          keto: [
            { name: 'Healthy Fats', importance: 'Primary energy substrate in ketosis â€” essential for performance.', sources: 'Avocado, MCT oil, olive oil, fatty fish, nuts', type: 'fat' },
            { name: 'Protein', importance: 'Preserves muscle mass while in a carb-restricted state.', sources: 'Beef, salmon, chicken, eggs, cheese', type: 'protein' },
            { name: 'Electrolytes', importance: 'Keto increases electrolyte loss â€” critical to prevent cramping.', sources: 'Pink salt, avocado (potassium), leafy greens (magnesium)', type: 'micro' },
            { name: 'Omega-3 Fatty Acids', importance: 'Reduces inflammation common with high-fat diets.', sources: 'Salmon, sardines, mackerel, walnuts', type: 'fat' },
          ],
          paleo: [
            { name: 'Lean Protein', importance: 'Core of the paleo diet â€” supports muscle repair and satiety.', sources: 'Chicken breast, beef, salmon, turkey, eggs', type: 'protein' },
            { name: 'Natural Carbohydrates', importance: 'Fuel from whole food sources without processed sugars.', sources: 'Sweet potato, fruits, root vegetables, plantain', type: 'carb' },
            { name: 'Omega-3 Fatty Acids', importance: 'Anti-inflammatory and joint-protective for active athletes.', sources: 'Wild salmon, sardines, walnuts, flaxseed', type: 'fat' },
            { name: 'Magnesium', importance: 'Muscle function, sleep quality, and energy metabolism.', sources: 'Leafy greens, pumpkin seeds, almonds, dark chocolate', type: 'micro' },
          ],
          mediterranean: [
            { name: 'Omega-3 from Fish', importance: 'Core of the Mediterranean diet â€” reduces inflammation and aids recovery.', sources: 'Sardines, salmon, tuna, mackerel', type: 'fat' },
            { name: 'Complex Carbohydrates', importance: 'Whole grain carbs provide sustained energy for training.', sources: 'Farro, whole wheat, barley, oats', type: 'carb' },
            { name: 'Polyphenols', importance: 'Antioxidants that reduce exercise-induced oxidative stress.', sources: 'Olive oil, berries, red grapes, herbs', type: 'micro' },
            { name: 'Plant Protein', importance: 'Legumes provide fiber, protein, and key micronutrients.', sources: 'Chickpeas, lentils, fava beans, hummus', type: 'protein' },
          ],
          balanced: [
            { name: 'Protein', importance: 'Essential for muscle repair and growth after training.', sources: 'Chicken, eggs, Greek yogurt', type: 'protein' },
            { name: 'Complex Carbohydrates', importance: 'Primary fuel source for high-intensity athletic performance.', sources: 'Oats, brown rice, sweet potato', type: 'carb' },
            { name: 'Omega-3 Fatty Acids', importance: 'Reduces inflammation and supports joint health.', sources: 'Salmon, walnuts, flaxseed', type: 'fat' },
            { name: 'Magnesium', importance: 'Critical for muscle function, sleep quality, and energy production.', sources: 'Leafy greens, nuts, seeds', type: 'micro' },
          ]
        };

        const dietKey = Object.keys(fallbackMeals).includes(dt) ? dt : 'balanced';

        setPlan({
          dailyCalories: tdee,
          macros: {
            protein: { grams: Math.round(tdee * (dt === 'keto' ? 0.25 : 0.30) / 4), calories: Math.round(tdee * (dt === 'keto' ? 0.25 : 0.30)), percent: dt === 'keto' ? 25 : 30 },
            carbs: { grams: Math.round(tdee * (dt === 'keto' ? 0.05 : dt === 'mediterranean' ? 0.50 : 0.45) / 4), calories: Math.round(tdee * (dt === 'keto' ? 0.05 : 0.45)), percent: dt === 'keto' ? 5 : dt === 'mediterranean' ? 50 : 45 },
            fat: { grams: Math.round(tdee * (dt === 'keto' ? 0.70 : 0.25) / 9), calories: Math.round(tdee * (dt === 'keto' ? 0.70 : 0.25)), percent: dt === 'keto' ? 70 : 25 }
          },
          meals: fallbackMeals[dietKey],
          keyNutrients: fallbackNutrients[dietKey],
          hydration: 'Aim for 35â€“45ml per kg of bodyweight daily. Add 500ml per hour of intense training. Monitor urine color â€” pale yellow indicates good hydration.',
          supplementSuggestions: dt === 'vegan'
            ? ['Vitamin B12 (1000mcg/day) â€“ essential, not available from plant foods', 'Algae-based Omega-3 DHA/EPA â€“ plant-based alternative to fish oil', 'Creatine monohydrate (5g/day) â€“ natural levels lower in vegans']
            : dt === 'keto'
            ? ['Electrolyte mix (sodium, potassium, magnesium) â€“ replenish keto losses', 'MCT oil (1â€“2 tbsp/day) â€“ rapid ketone fuel for performance', 'Creatine monohydrate (5g/day) â€“ preserves strength in carb-restricted state']
            : ['Creatine monohydrate (5g/day) â€“ well-evidenced for strength and power', 'Vitamin D3 (2000 IU/day) â€“ supports immune function and bone health', 'Magnesium glycinate (300mg/night) â€“ improves sleep and muscle recovery'],
          tip: dt === 'vegan'
            ? 'Combine complementary plant proteins (e.g. rice + beans) throughout the day to ensure all essential amino acids. A pea or soy protein supplement makes hitting your protein target much easier.'
            : dt === 'vegetarian'
            ? 'Pair iron-rich plant foods like lentils and spinach with vitamin C sources to boost absorption. Time your whey or Greek yogurt intake within 30 minutes post-workout for optimal recovery.'
            : 'Timing your meals around training makes a significant difference. Eat a carb-rich meal 2â€“3 hours before training and a protein + carb combo within 30â€“45 minutes after.'
        });
        setLoading(false);
      };

      const cal = calcCalories();
      const pillClass = { protein: 'pill-protein', carb: 'pill-carb', fat: 'pill-fat', micro: 'pill-micro' };
      const mealColors = ['#DBEAFE','#FCE7F3','#D1FAE5','#FEF9C3','#EDE9FE','#FEF2F2'];

      return (
        <div>
          <h2 className="module-title">ðŸ¥— Nutrition & Diet Plan</h2>
          <p className="module-subtitle">Personalized meal planning and macros based on your body metrics, sport, and goals</p>

          {/* Diet preference badge */}
          <div style={{display:'flex', alignItems:'center', gap:'10px', marginBottom:'20px', padding:'12px 16px', background:'rgba(0,229,255,0.06)', borderRadius:'10px', border:'1px solid rgba(0,229,255,0.18)'}}>
            <span style={{fontSize:'20px'}}>
              {(profile?.dietType === 'vegan') ? 'ðŸŒ±' : (profile?.dietType === 'vegetarian') ? 'ðŸ¥¦' : (profile?.dietType === 'keto') ? 'ðŸ¥‘' : (profile?.dietType === 'paleo') ? 'ðŸ¥©' : (profile?.dietType === 'mediterranean') ? 'ðŸ«’' : 'ðŸ½ï¸'}
            </span>
            <div>
              <div style={{fontSize:'11px', color:'var(--text-dim)', letterSpacing:'1px', textTransform:'uppercase', fontWeight:'600'}}>Diet Preference from Profile</div>
              <div style={{fontSize:'15px', fontWeight:'700', color:'var(--primary)'}}>{getDietLabel()}</div>
            </div>
            {!profile?.dietType && (
              <span style={{marginLeft:'auto', fontSize:'12px', color:'var(--warning)'}}>âš ï¸ Set in Profile for custom plan</span>
            )}
          </div>

          {cal && !plan && (
            <div className="grid-3" style={{marginBottom:'24px'}}>
              {[
                { label: 'Estimated BMR', value: `${cal.bmr} kcal`, desc: 'At complete rest' },
                { label: 'Daily TDEE', value: `${cal.tdee} kcal`, desc: 'Total daily energy expenditure' },
                { label: 'Training Days', value: profile?.weeklyTraining || '3-4', desc: 'Days per week' }
              ].map(s => (
                <div key={s.label} className="metric-card" style={{textAlign:'center'}}>
                  <div className="metric-label">{s.label}</div>
                  <div className="metric-value" style={{fontSize:'22px'}}>{s.value}</div>
                  <div style={{fontSize:'12px', color:'var(--text-dim)'}}>{s.desc}</div>
                </div>
              ))}
            </div>
          )}

          {!plan && !loading && (
            <div style={{textAlign:'center', padding:'32px 20px'}}>
              <div style={{fontSize:'64px', marginBottom:'16px'}}>ðŸ½ï¸</div>
              <h3 style={{fontSize:'20px', fontWeight:'700', marginBottom:'8px'}}>Get Your Personalized Meal Plan</h3>
              <p style={{color:'var(--text-dim)', marginBottom:'24px', maxWidth:'400px', margin:'0 auto 24px'}}>
                {profile?.age || profile?.weight ? 'Your profile is ready. Click to generate a science-backed nutrition plan tailored to your sport and goals.' : 'Fill in your Profile for a fully personalized plan, or generate a general athletic nutrition plan now.'}
              </p>
              <button className="btn btn-primary" onClick={generateDietPlan}>
                ðŸ¥— Generate My Nutrition Plan
              </button>
            </div>
          )}

          {loading && (
            <div style={{textAlign:'center', padding:'48px'}}>
              <div className="spinner" style={{margin:'0 auto 16px'}} />
              <p style={{color:'var(--text-dim)'}}>Calculating your personalized nutrition plan...</p>
            </div>
          )}

          {plan && !loading && (
            <div>
              {/* Calorie & Macro Summary */}
              <div style={{background:'var(--bg-3)', borderRadius:'16px', padding:'24px', marginBottom:'24px', color:'white'}}>
                <div style={{display:'flex', justifyContent:'space-between', alignItems:'center', marginBottom:'16px', flexWrap:'wrap', gap:'12px'}}>
                  <div>
                    <div style={{fontSize:'13px', opacity:0.7, marginBottom:'4px'}}>DAILY TARGET</div>
                    <div style={{fontSize:'42px', fontWeight:'900'}}>{plan.dailyCalories.toLocaleString()} <span style={{fontSize:'18px', opacity:0.7}}>kcal</span></div>
                    <div style={{fontSize:'12px', marginTop:'4px', opacity:0.7}}>
                      {(profile?.dietType === 'vegan') ? 'ðŸŒ± Vegan Plan' : (profile?.dietType === 'vegetarian') ? 'ðŸ¥¦ Vegetarian Plan' : (profile?.dietType === 'keto') ? 'ðŸ¥‘ Keto Plan' : (profile?.dietType === 'paleo') ? 'ðŸ¥© Paleo Plan' : (profile?.dietType === 'mediterranean') ? 'ðŸ«’ Mediterranean Plan' : 'ðŸ½ï¸ Balanced Plan'}
                    </div>
                  </div>
                  <button className="btn btn-secondary" style={{padding:'8px 16px', fontSize:'13px'}} onClick={() => { setPlan(null); }}>ðŸ”„ Regenerate</button>
                </div>
                <div style={{display:'grid', gridTemplateColumns:'repeat(3,1fr)', gap:'12px'}}>
                  {[
                    { name:'Protein', color:'#60A5FA', data: plan.macros.protein },
                    { name:'Carbs', color:'#FCD34D', data: plan.macros.carbs },
                    { name:'Fat', color:'#F9A8D4', data: plan.macros.fat }
                  ].map(m => (
                    <div key={m.name} style={{background:'rgba(0,229,255,0.05)', borderRadius:'10px', padding:'14px', textAlign:'center'}}>
                      <div style={{fontSize:'11px', opacity:0.7, marginBottom:'4px'}}>{m.name}</div>
                      <div style={{fontSize:'22px', fontWeight:'800', color: m.color}}>{m.data.grams}g</div>
                      <div style={{fontSize:'11px', opacity:0.6}}>{m.data.percent}% Â· {m.data.calories} kcal</div>
                      <div style={{height:'4px', background:'rgba(255,255,255,0.15)', borderRadius:'2px', marginTop:'8px'}}>
                        <div style={{height:'100%', width:`${m.data.percent}%`, background: m.color, borderRadius:'2px'}} />
                      </div>
                    </div>
                  ))}
                </div>
              </div>

              {/* Meal Plan */}
              <h3 style={{fontSize:'18px', fontWeight:'700', marginBottom:'16px'}}>ðŸ½ï¸ Daily Meal Schedule</h3>
              <div style={{display:'grid', gap:'12px', marginBottom:'28px'}}>
                {plan.meals.map((meal, i) => (
                  <div key={meal.name} className="diet-card" style={{borderLeft: `4px solid ${mealColors[i]}`, background: `${mealColors[i]}22`}}>
                    <div style={{display:'flex', justifyContent:'space-between', alignItems:'flex-start', flexWrap:'wrap', gap:'8px', marginBottom:'8px'}}>
                      <div>
                        <div style={{fontWeight:'800', fontSize:'16px'}}>{meal.name}</div>
                        <div style={{fontSize:'12px', color:'var(--text-dim)'}}>{meal.time}</div>
                      </div>
                      <div style={{fontWeight:'800', fontSize:'20px', color:'var(--primary)'}}>{meal.calories} kcal</div>
                    </div>
                    <p style={{fontSize:'14px', color:'var(--text)', marginBottom:'10px', lineHeight:'1.5'}}>{meal.description}</p>
                    <div style={{display:'flex', flexWrap:'wrap', gap:'6px'}}>
                      {(meal.foods||[]).map(f => (
                        <span key={f} style={{background:'var(--bg-3)', border:'1px solid var(--border)', borderRadius:'6px', padding:'3px 10px', fontSize:'12px', color:'var(--text)'}}>
                          {f}
                        </span>
                      ))}
                    </div>
                  </div>
                ))}
              </div>

              {/* Key Nutrients */}
              <h3 style={{fontSize:'18px', fontWeight:'700', marginBottom:'16px'}}>ðŸ”‘ Key Nutrients for Your Goals</h3>
              <div style={{display:'grid', gap:'10px', marginBottom:'28px'}}>
                {(plan.keyNutrients||[]).map(n => (
                  <div key={n.name} className="diet-card">
                    <div style={{display:'flex', alignItems:'flex-start', gap:'12px'}}>
                      <span className={`diet-pill ${pillClass[n.type] || 'pill-micro'}`}>{n.name}</span>
                      <div style={{flex:1}}>
                        <div style={{fontSize:'14px', color:'var(--text)', marginBottom:'4px'}}>{n.importance}</div>
                        <div style={{fontSize:'13px', color:'var(--text-dim)'}}>ðŸ“ Best sources: {n.sources}</div>
                      </div>
                    </div>
                  </div>
                ))}
              </div>

              {/* Hydration */}
              <div style={{background:'linear-gradient(135deg,#DBEAFE,#BFDBFE)', borderRadius:'14px', padding:'20px', marginBottom:'20px'}}>
                <h3 style={{fontSize:'16px', fontWeight:'700', marginBottom:'8px'}}>ðŸ’§ Hydration Strategy</h3>
                <p style={{fontSize:'14px', color:'var(--text)', lineHeight:'1.6'}}>{plan.hydration}</p>
              </div>

              {/* Supplements */}
              {plan.supplementSuggestions && (
                <div style={{background:'var(--bg-light)', borderRadius:'14px', padding:'20px', marginBottom:'20px'}}>
                  <h3 style={{fontSize:'16px', fontWeight:'700', marginBottom:'12px'}}>ðŸ’Š Evidence-Based Supplements</h3>
                  {plan.supplementSuggestions.map((s, i) => (
                    <div key={i} style={{display:'flex', gap:'10px', marginBottom:'10px', alignItems:'flex-start'}}>
                      <span style={{background:'var(--primary)', color:'white', borderRadius:'50%', width:'22px', height:'22px', display:'flex', alignItems:'center', justifyContent:'center', fontSize:'11px', fontWeight:'700', flexShrink:0, marginTop:'1px'}}>{i+1}</span>
                      <span style={{fontSize:'14px', color:'var(--text)', lineHeight:'1.5'}}>{s}</span>
                    </div>
                  ))}
                </div>
              )}

              {/* Pro Tip */}
              {plan.tip && (
                <div style={{background:'linear-gradient(135deg,#F0FDF4,#DCFCE7)', borderRadius:'14px', padding:'20px', borderLeft:'4px solid #10B981'}}>
                  <div style={{fontWeight:'700', marginBottom:'6px'}}>ðŸ’¡ Pro Nutrition Tip</div>
                  <p style={{fontSize:'14px', color:'var(--text)', lineHeight:'1.6'}}>{plan.tip}</p>
                </div>
              )}

              <div style={{background:'var(--bg-2)', borderRadius:'12px', padding:'16px', marginTop:'16px', borderLeft:'4px solid var(--text-light)'}}>
                <div style={{fontSize:'12px', color:'var(--text-dim)', lineHeight:'1.6'}}>
                  âš•ï¸ <strong>Disclaimer:</strong> This nutrition plan is AI-generated for educational purposes. Individual needs vary based on health conditions, medications, and other factors. Consult a registered dietitian or sports nutritionist for personalized medical nutrition therapy.
                </div>
              </div>
            </div>
          )}
        </div>
      );
    }

    // Webcam Module
    function WebcamModule({ webcamVideoRef, webcamCanvasRef, webcamStatus, webcamCountdown, webcamSeconds, videoFile,
      onStartPreview, onStop, onStartCountdown, onStopRecording, onUseVideo, onRetake }) {

      const { useState: useLocalState, useEffect: useLocalEffect, useMemo } = React;
      const recordedURL = useMemo(() => {
        if (isRecorded && videoFile) return URL.createObjectURL(videoFile);
        return null;
      }, [videoFile, webcamStatus]);
      useLocalEffect(() => () => { if (recordedURL) URL.revokeObjectURL(recordedURL); }, [recordedURL]);
      const isIdle = webcamStatus === 'idle';
      const isPreview = webcamStatus === 'preview';
      const isCountdown = webcamStatus === 'countdown';
      const isRecording = webcamStatus === 'recording';
      const isRecorded = webcamStatus === 'recorded';
      const showCamera = isPreview || isCountdown || isRecording;

      return (
        <div>
          <h2 className="module-title">ðŸ“· Webcam Recording</h2>
          <p className="module-subtitle">Record yourself live for instant AI analysis</p>

          {/* Camera view */}
          <div style={{
            position: 'relative', borderRadius: '16px', overflow: 'hidden',
            background: '#000', marginBottom: '24px',
            minHeight: showCamera || isRecorded ? '360px' : '0',
            display: showCamera || isRecorded ? 'block' : 'none'
          }}>
            <video
              ref={webcamVideoRef}
              autoPlay
              playsInline
              muted
              style={{
                width: '100%', display: showCamera ? 'block' : 'none',
                maxHeight: '480px', transform: 'scaleX(-1)'
              }}
            />
            {/* Live skeleton canvas overlay */}
            {showCamera && (
              <canvas
                ref={webcamCanvasRef}
                style={{
                  position: 'absolute', top: 0, left: 0,
                  width: '100%', height: '100%',
                  transform: 'scaleX(-1)',
                  pointerEvents: 'none'
                }}
              />
            )}

            {/* Recorded preview */}
            {isRecorded && videoFile && (
              <video
                src={recordedURL}
                controls
                style={{ width: '100%', maxHeight: '480px' }}
              />
            )}

            {/* Countdown overlay */}
            {isCountdown && (
              <div style={{
                position: 'absolute', inset: 0, display: 'flex',
                alignItems: 'center', justifyContent: 'center',
                background: 'rgba(0,0,0,0.55)'
              }}>
                <div style={{
                  fontSize: '120px', fontWeight: '900', color: 'var(--primary)',
                  textShadow: '0 0 60px rgba(0,229,255,0.8)',
                  animation: 'pulse 1s ease-in-out'
                }}>
                  {webcamCountdown}
                </div>
              </div>
            )}

            {/* Recording indicator */}
            {isRecording && (
              <div style={{
                position: 'absolute', top: '16px', left: '16px',
                display: 'flex', alignItems: 'center', gap: '10px',
                background: 'rgba(0,0,0,0.65)', borderRadius: '20px', padding: '8px 16px'
              }}>
                <div style={{
                  width: '12px', height: '12px', borderRadius: '50%',
                  background: 'var(--error)',
                  animation: 'pulse 1s ease-in-out infinite'
                }} />
                <span style={{ color: 'var(--text)', fontWeight: '700', fontSize: '14px' }}>
                  REC {String(Math.floor(webcamSeconds / 60)).padStart(2,'0')}:{String(webcamSeconds % 60).padStart(2,'0')} / 0:30
                </span>
              </div>
            )}

            {/* Progress bar for recording */}
            {isRecording && (
              <div style={{
                position: 'absolute', bottom: 0, left: 0, right: 0, height: '4px',
                background: 'rgba(255,255,255,0.2)'
              }}>
                <div style={{
                  height: '100%', background: 'var(--error)',
                  width: `${(webcamSeconds / 30) * 100}%`,
                  transition: 'width 1s linear'
                }} />
              </div>
            )}
          </div>

          {/* Controls */}
          <div className="button-group">
            {isIdle && (
              <button className="btn btn-primary" onClick={onStartPreview}>
                ðŸ“· Start Camera
              </button>
            )}

            {isPreview && (
              <>
                <button className="btn btn-primary" onClick={onStartCountdown}>
                  âº Record (3s countdown)
                </button>
                <button className="btn btn-secondary" onClick={onStop}>
                  âœ• Cancel
                </button>
              </>
            )}

            {isCountdown && (
              <button className="btn btn-secondary" onClick={onStop}>
                âœ• Cancel
              </button>
            )}

            {isRecording && (
              <button className="btn btn-primary" onClick={onStopRecording} style={{ background: 'linear-gradient(135deg,#EF4444,#B91C1C)' }}>
                â¹ Stop Recording
              </button>
            )}

            {isRecorded && (
              <>
                <button className="btn btn-primary" onClick={onUseVideo}>
                  âœ… Analyze This Video
                </button>
                <button className="btn btn-secondary" onClick={onRetake}>
                  ðŸ”„ Retake
                </button>
              </>
            )}
          </div>

          {/* Tips */}
          {isIdle && (
            <div style={{
              marginTop: '24px', background: 'var(--bg-light)',
              borderRadius: '12px', padding: '24px'
            }}>
              <h3 style={{ fontSize: '18px', fontWeight: '700', marginBottom: '16px' }}>ðŸ“‹ Webcam Tips</h3>
              <ul style={{ marginLeft: '20px', color: 'var(--text)', lineHeight: '1.8' }}>
                <li>Stand 2â€“3 metres from the camera so your full body is visible</li>
                <li>Use good lighting â€” face a window or lamp</li>
                <li>Record your movement from the side for best pose detection</li>
                <li>Perform a clear, complete athletic movement (jump, kick, swing, etc.)</li>
                <li>Recording auto-stops after 30 seconds</li>
              </ul>
            </div>
          )}

          {isRecorded && (
            <div style={{
              marginTop: '20px', padding: '16px',
              background: 'linear-gradient(135deg,#D1FAE5,#A7F3D0)',
              borderRadius: '12px', textAlign: 'center'
            }}>
              <p style={{ fontWeight: '600', color: '#065F46' }}>
                âœ… Recording saved! Click "Analyze This Video" to run the AI analysis.
              </p>
            </div>
          )}
        </div>
      );
    }

    // Upload Module
    function UploadModule({ onFileSelect, videoFile, fileInputRef }) {
      return (
        <div>
          <h2 className="module-title">Upload Your Video</h2>
          <p className="module-subtitle">
            Upload a video of your athletic performance for AI analysis
          </p>

          <input
            ref={fileInputRef}
            type="file"
            accept="video/*"
            onChange={onFileSelect}
            style={{ display: 'none' }}
          />

          <div 
            className="upload-zone"
            onClick={() => fileInputRef.current?.click()}
          >
            <div className="upload-icon">
              {videoFile ? 'âœ…' : 'ðŸ“¹'}
            </div>
            <div className="upload-text">
              {videoFile ? videoFile.name : 'Click to upload video'}
            </div>
            <div className="upload-hint">
              {videoFile 
                ? `${(videoFile.size / 1024 / 1024).toFixed(1)} MB â€¢ Ready to analyze`
                : 'Supports MP4, WebM, MOV, AVI (max 100MB)'
              }
            </div>
          </div>

          <div style={{ 
            background: 'var(--bg-light)', 
            padding: '24px', 
            borderRadius: '12px',
            marginTop: '24px'
          }}>
            <h3 style={{ fontSize: '18px', fontWeight: '700', marginBottom: '16px' }}>
              ðŸ“‹ Tips for Best Results
            </h3>
            <ul style={{ 
              marginLeft: '20px', 
              color: 'var(--text)',
              lineHeight: '1.8'
            }}>
              <li>Ensure the full body is visible in the frame</li>
              <li>Use good lighting conditions</li>
              <li>Keep the camera stable (tripod recommended)</li>
              <li>Record from a side or angled view</li>
              <li>Video length: Any duration (3-10 seconds optimal, longer videos are analyzed intelligently)</li>
              <li>Minimum resolution: 720p</li>
            </ul>
          </div>

          <div className="grid-3" style={{ marginTop: '32px' }}>
            {Object.values(SPORT_PATTERNS).slice(0, 6).map((sport) => (
              <div 
                key={sport.name}
                style={{
                  padding: '20px',
                  background: 'var(--bg-2)',
                  borderRadius: '12px',
                  border: '1px solid var(--border)',
                  textAlign: 'center'
                }}
              >
                <div style={{ fontSize: '32px', marginBottom: '8px' }}>
                  {sport.emoji}
                </div>
                <div style={{ fontSize: '14px', fontWeight: '600', color: 'var(--text)' }}>
                  {sport.name}
                </div>
              </div>
            ))}
          </div>
        </div>
      );
    }

    // Analyze Module
    function AnalyzeModule({ videoRef, canvasRef, analyzing, progress, onAnalyze, videoFile }) {
      return (
        <div>
          <h2 className="module-title">Analyze Video</h2>
          <p className="module-subtitle">
            AI pose detection and performance analysis
          </p>

          {videoFile && (
            <div className="video-container">
              <video
                ref={videoRef}
                className="video-player"
                controls
                style={{ display: analyzing ? 'none' : 'block' }}
              />
              <canvas
                ref={canvasRef}
                className="canvas-overlay"
                style={{ display: analyzing ? 'block' : 'none' }}
              />
              {analyzing && (
                <div className="processing-overlay">
                  <div className="spinner"></div>
                  <div>
                    <div style={{ fontSize: '18px', fontWeight: '700', marginBottom: '8px' }}>
                      Analyzing Performance...
                    </div>
                    <div style={{ fontSize: '14px', opacity: '0.9' }}>
                      {progress < 30 ? 'Detecting pose landmarks...' :
                       progress < 60 ? 'Processing movement patterns...' :
                       progress < 80 ? 'Analyzing technique...' :
                       progress < 90 ? 'ðŸ¤– Validating sport with Claude AI...' :
                       'Generating insights...'}
                    </div>
                    <div style={{ 
                      marginTop: '16px', 
                      fontSize: '24px', 
                      fontWeight: '700' 
                    }}>
                      {Math.round(progress)}%
                    </div>
                  </div>
                </div>
              )}
            </div>
          )}

          <div className="button-group">
            <button
              className="btn btn-primary"
              onClick={onAnalyze}
              disabled={analyzing || !videoFile}
            >
              {analyzing ? 'Analyzing...' : 'ðŸš€ Start Analysis'}
            </button>
          </div>

          <div style={{
            marginTop: '32px',
            padding: '24px',
            background: 'var(--bg-3)',
            borderRadius: '12px'
          }}>
            <h3 style={{ fontSize: '18px', fontWeight: '700', marginBottom: '12px' }}>
              ðŸ¤– What We Analyze
            </h3>
            <div className="grid-2">
              <div>
                <div style={{ fontSize: '16px', fontWeight: '600', marginBottom: '8px' }}>
                  âœ“ Body Angles
                </div>
                <div style={{ fontSize: '14px', color: 'var(--text-dim)' }}>
                  Ankle, knee, hip, and arm positioning
                </div>
              </div>
              <div>
                <div style={{ fontSize: '16px', fontWeight: '600', marginBottom: '8px' }}>
                  âœ“ Movement Speed
                </div>
                <div style={{ fontSize: '14px', color: 'var(--text-dim)' }}>
                  Velocity and explosive power metrics
                </div>
              </div>
              <div>
                <div style={{ fontSize: '16px', fontWeight: '600', marginBottom: '8px' }}>
                  âœ“ Consistency
                </div>
                <div style={{ fontSize: '14px', color: 'var(--text-dim)' }}>
                  Movement pattern repeatability
                </div>
              </div>
              <div>
                <div style={{ fontSize: '16px', fontWeight: '600', marginBottom: '8px' }}>
                  âœ“ Balance & Form
                </div>
                <div style={{ fontSize: '14px', color: 'var(--text-dim)' }}>
                  Stability and technique quality
                </div>
              </div>
            </div>
          </div>
        </div>
      );
    }

    // Results Module
    function ResultsModule({ results }) {
      const scoreColor = results.score >= 80 ? 'var(--success)' : 
                         results.score >= 60 ? 'var(--warning)' : 'var(--error)';

      // Handle "not a sport" case
      if (results.sport === 'not-a-sport') {
        return (
          <div>
            <div className="error-message">
              <div className="error-icon">ðŸš«</div>
              <div className="error-title">Not a Sport Detected</div>
              <div className="error-text">
                The movement in your video doesn't match any of our supported sports. 
                The analysis could only achieve {results.confidence}% confidence (minimum 45% required).
              </div>
            </div>

            <div style={{ marginTop: '24px' }}>
              <h3 style={{ fontSize: '20px', fontWeight: '700', marginBottom: '16px' }}>
                Recommendations
              </h3>
              
              {results.insights.map((insight, index) => (
                <div 
                  key={index}
                  className="insight-card"
                  style={{
                    background: insight.severity === 'high' 
                      ? 'linear-gradient(135deg, #FEE2E2 0%, #FECACA 100%)'
                      : insight.severity === 'medium'
                      ? 'linear-gradient(135deg, #FEF3C7 0%, #FDE68A 100%)'
                      : 'linear-gradient(135deg, #D1FAE5 0%, #A7F3D0 100%)'
                  }}
                >
                  <div className="insight-icon">{insight.icon}</div>
                  <div className="insight-content">
                    <div className="insight-title">{insight.category}</div>
                    <div className="insight-text">{insight.message}</div>
                  </div>
                </div>
              ))}
            </div>

            <div style={{ 
              marginTop: '32px',
              padding: '24px',
              background: 'var(--bg-light)',
              borderRadius: '12px'
            }}>
              <h3 style={{ fontSize: '18px', fontWeight: '700', marginBottom: '16px' }}>
                âœ… Supported Sports
              </h3>
              <div className="grid-3">
                {Object.values(SPORT_PATTERNS).map((sport) => (
                  <div 
                    key={sport.name}
                    style={{
                      padding: '12px',
                      background: 'var(--bg-2)',
                      borderRadius: '8px',
                      textAlign: 'center',
                      border: '1px solid var(--border)'
                    }}
                  >
                    <div style={{ fontSize: '24px', marginBottom: '4px' }}>
                      {sport.emoji}
                    </div>
                    <div style={{ fontSize: '12px', fontWeight: '600', color: 'var(--text)' }}>
                      {sport.name}
                    </div>
                  </div>
                ))}
              </div>
            </div>

            {results.detectionDetails && (
              <div style={{ 
                marginTop: '24px',
                padding: '20px',
                background: 'var(--bg-2)',
                borderRadius: '12px',
                border: '1px solid var(--border)'
              }}>
                <h3 style={{ fontSize: '16px', fontWeight: '700', marginBottom: '12px' }}>
                  ðŸ“Š Detection Details
                </h3>
                <div style={{ fontSize: '14px', lineHeight: '2', color: 'var(--text)' }}>
                  <div><strong>Top Match:</strong> {results.detectionDetails.topMatch} ({results.detectionDetails.topMatchScore}%)</div>
                  {results.detectionDetails.secondMatch && (
                    <div><strong>Second Match:</strong> {results.detectionDetails.secondMatch} ({results.detectionDetails.secondMatchScore}%)</div>
                  )}
                  {results.detectionDetails.confidenceGap !== undefined && (
                    <div><strong>Confidence Gap:</strong> {results.detectionDetails.confidenceGap}% {results.detectionDetails.confidenceGap < 10 ? '(too close - ambiguous)' : '(clear winner)'}</div>
                  )}
                  <div><strong>Athletic Movement:</strong> {results.detectionDetails.hasSignificantMovement ? 'âœ“ Yes' : 'âœ— No'} {results.detectionDetails.avgSpeed && `(${results.detectionDetails.avgSpeed})`}</div>
                  <div><strong>Movement Variation:</strong> {results.detectionDetails.hasMovementVariation ? 'âœ“ Dynamic' : 'âœ— Static'} {results.detectionDetails.speedVariation && `(${results.detectionDetails.speedVariation})`}</div>
                  <div><strong>Balance Detected:</strong> {results.detectionDetails.hasBalance ? 'âœ“ Yes' : 'âœ— No'}</div>
                  <div><strong>Pattern Consistency:</strong> {results.detectionDetails.hasConsistency ? 'âœ“ Yes' : 'âœ— No'}</div>
                  <div><strong>Athletic Angles:</strong> {results.detectionDetails.hasAthleticAngles ? 'âœ“ Yes' : 'âœ— No'}</div>
                  <div><strong>Data Points:</strong> {results.detectionDetails.dataPoints} frames (min 10 required)</div>
                  <div><strong>Required Confidence:</strong> 55% minimum</div>
                </div>
              </div>
            )}

            <div style={{
              marginTop: '24px',
              padding: '20px',
              background: 'var(--bg-3)',
              borderRadius: '12px',
              textAlign: 'center'
            }}>
              <p style={{ fontSize: '14px', color: 'var(--text)', lineHeight: '1.6' }}>
                ðŸ’¡ <strong>Tip:</strong> Upload a new video showing one of the sports above for accurate analysis
              </p>
            </div>
          </div>
        );
      }

      // Normal sport detection results
      return (
        <div>
          <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', flexWrap: 'wrap', gap: '12px', marginBottom: '8px' }}>
            <div className="status-badge status-success">âœ“ Analysis Complete</div>
            <div style={{ display: 'flex', gap: '8px', flexWrap: 'wrap' }}>
              <button className="btn btn-secondary" style={{ fontSize: '13px', padding: '8px 16px' }}
                onClick={() => {
                  const el = document.getElementById('report-printable');
                  if (el) { el.style.display = 'block'; window.print(); el.style.display = 'none'; }
                  else window.print();
                }}>
                ðŸ“„ Export PDF
              </button>
            </div>
          </div>

          <h2 className="module-title">Performance Analysis</h2>
          <p className="module-subtitle">
            Detected: {SPORT_PATTERNS[results.sport].emoji} {results.sportName}
          </p>

          <div className="grid-2">
            <div className="metric-card">
              <div className="metric-label">Overall Score</div>
              <div className="metric-value" style={{ color: scoreColor }}>
                {results.score}/100
              </div>
              <div style={{ fontSize: '14px', color: 'var(--text-dim)' }}>
                {results.score >= 85 ? 'Elite Performance' :
                 results.score >= 70 ? 'Advanced Level' :
                 results.score >= 60 ? 'Intermediate Level' :
                 'Developing Skills'}
              </div>
            </div>

            <div className="metric-card">
              <div className="metric-label">Frames Analyzed</div>
              <div className="metric-value">{results.frameCount}</div>
              <div style={{ fontSize: '14px', color: 'var(--text-dim)' }}>
                {(results.frameCount / 30).toFixed(1)}s of movement
              </div>
            </div>
          </div>

          {/* Extended biomechanics metrics */}
          <div className="grid-3" style={{ marginTop: '16px' }}>
            {[
              { label: 'Knee ROM', value: `${results.metrics?.kneeROM ?? 'â€”'}Â°`, hint: 'Range of motion' },
              { label: 'Hip ROM', value: `${results.metrics?.hipROM ?? 'â€”'}Â°`, hint: 'Range of motion' },
              { label: 'Avg Knee Angle', value: `${results.metrics?.avgAnkleKneeAngle ?? 'â€”'}Â°`, hint: 'Mean flexion' },
              { label: 'Avg Hip Angle', value: `${results.metrics?.avgHipAngle ?? 'â€”'}Â°`, hint: 'Mean flexion' },
              { label: 'Torso Lean', value: `${results.metrics?.avgTorsoLean ?? 'â€”'}Â°`, hint: 'Forward lean' },
              { label: 'Wrist Speed', value: results.metrics?.avgWristSpeed ?? 'â€”', hint: 'Strike index' },
            ].map(m => (
              <div key={m.label} style={{
                padding: '14px 16px',
                background: 'var(--bg-2)',
                borderRadius: '10px',
                border: '1px solid var(--border)',
              }}>
                <div style={{ fontSize: '11px', color: 'var(--text-dim)', textTransform: 'uppercase', letterSpacing: '0.5px' }}>{m.hint}</div>
                <div style={{ fontSize: '22px', fontWeight: '800', color: 'var(--primary)', margin: '4px 0' }}>{m.value}</div>
                <div style={{ fontSize: '12px', color: 'var(--text)', fontWeight: '600' }}>{m.label}</div>
              </div>
            ))}
          </div>

          <div style={{ marginTop: '32px' }}>
            <h3 style={{ fontSize: '20px', fontWeight: '700', marginBottom: '16px' }}>
              Detailed Breakdown
            </h3>
            
            {Object.entries(results.scores).map(([category, score]) => (
              <div key={category} style={{ marginBottom: '20px' }}>
                <div style={{
                  display: 'flex',
                  justifyContent: 'space-between',
                  marginBottom: '8px'
                }}>
                  <span style={{ fontWeight: '600' }}>
                    {category.charAt(0).toUpperCase() + category.slice(1)}
                  </span>
                  <span style={{ 
                    fontWeight: '700',
                    color: score >= 80 ? 'var(--success)' : score >= 60 ? 'var(--warning)' : 'var(--error)'
                  }}>
                    {score}/100
                  </span>
                </div>
                <div className="progress-bar">
                  <div 
                    className="progress-fill" 
                    style={{ width: `${score}%` }}
                  ></div>
                </div>
              </div>
            ))}
          </div>

          <div style={{ marginTop: '32px' }}>
            <h3 style={{ fontSize: '20px', fontWeight: '700', marginBottom: '16px' }}>
              Recommendations
            </h3>
            
            {results.insights.map((insight, index) => (
              <div 
                key={index}
                className="insight-card"
                style={{
                  background: insight.severity === 'high' 
                    ? 'linear-gradient(135deg, #FEE2E2 0%, #FECACA 100%)'
                    : insight.severity === 'medium'
                    ? 'linear-gradient(135deg, #FEF3C7 0%, #FDE68A 100%)'
                    : 'linear-gradient(135deg, #D1FAE5 0%, #A7F3D0 100%)'
                }}
              >
                <div className="insight-icon">{insight.icon}</div>
                <div className="insight-content">
                  <div className="insight-title">{insight.category} Focus</div>
                  <div className="insight-text">{insight.message}</div>
                </div>
              </div>
            ))}
          </div>

          {results.alternatives && results.alternatives.length > 0 && (
            <div style={{ 
              marginTop: '32px',
              padding: '24px',
              background: 'var(--bg-light)',
              borderRadius: '12px'
            }}>
              <h3 style={{ fontSize: '18px', fontWeight: '700', marginBottom: '12px' }}>
                Alternative Sport Matches
              </h3>
              <p style={{ fontSize: '14px', color: 'var(--text-dim)', marginBottom: '16px' }}>
                Your movement patterns also show similarities to:
              </p>
              {results.alternatives.map((alt, index) => (
                <div 
                  key={index}
                  style={{
                    padding: '12px',
                    background: 'var(--bg-2)',
                    borderRadius: '8px',
                    marginBottom: '8px',
                    display: 'flex',
                    justifyContent: 'space-between',
                    alignItems: 'center'
                  }}
                >
                  <span style={{ fontWeight: '600' }}>
                    {SPORT_PATTERNS[alt.sport].emoji} {SPORT_PATTERNS[alt.sport].name}
                  </span>
                  <span style={{ color: 'var(--text-dim)' }}>
                    {alt.confidence}% match
                  </span>
                </div>
              ))}
            </div>
          )}

          {/* Technical Metrics Section */}
          <div style={{ 
            marginTop: '32px',
            padding: '24px',
            background: 'var(--bg-3)',
            borderRadius: '12px'
          }}>
            <h3 style={{ fontSize: '18px', fontWeight: '700', marginBottom: '16px' }}>
              ðŸ“ Technical Metrics
            </h3>
            <div className="grid-3">
              <div>
                <div style={{ fontSize: '12px', color: 'var(--text-dim)', marginBottom: '4px' }}>
                  Ankle-Knee Angle
                </div>
                <div style={{ fontSize: '20px', fontWeight: '700', color: 'var(--primary)' }}>
                  {results.metrics.avgAnkleKneeAngle}Â°
                </div>
              </div>
              <div>
                <div style={{ fontSize: '12px', color: 'var(--text-dim)', marginBottom: '4px' }}>
                  Hip Angle
                </div>
                <div style={{ fontSize: '20px', fontWeight: '700', color: 'var(--primary)' }}>
                  {results.metrics.avgHipAngle}Â°
                </div>
              </div>
              <div>
                <div style={{ fontSize: '12px', color: 'var(--text-dim)', marginBottom: '4px' }}>
                  Arm Swing
                </div>
                <div style={{ fontSize: '20px', fontWeight: '700', color: 'var(--primary)' }}>
                  {results.metrics.avgArmSwing}Â°
                </div>
              </div>
              <div>
                <div style={{ fontSize: '12px', color: 'var(--text-dim)', marginBottom: '4px' }}>
                  Avg Speed
                </div>
                <div style={{ fontSize: '20px', fontWeight: '700', color: 'var(--primary)' }}>
                  {results.metrics.avgSpeed} m/s
                </div>
              </div>
              <div>
                <div style={{ fontSize: '12px', color: 'var(--text-dim)', marginBottom: '4px' }}>
                  Balance
                </div>
                <div style={{ fontSize: '20px', fontWeight: '700', color: 'var(--primary)' }}>
                  {results.metrics.balance}%
                </div>
              </div>
              <div>
                <div style={{ fontSize: '12px', color: 'var(--text-dim)', marginBottom: '4px' }}>
                  Timing
                </div>
                <div style={{ fontSize: '20px', fontWeight: '700', color: 'var(--primary)' }}>
                  {results.metrics.timing}%
                </div>
              </div>
            </div>
          </div>

          {/* Side-by-side pro comparison */}
          <CompareModule results={results} />

        </div>
      );
    }

    // Training Module
    function TrainingModule({ results }) {
      // Handle "not a sport" case - no training plan available
      if (results.sport === 'not-a-sport') {
        return (
          <div>
            <h2 className="module-title">Training Plan</h2>
            <p className="module-subtitle">
              No training plan available - sport not detected
            </p>

            <div className="error-message">
              <div className="error-icon">âš ï¸</div>
              <div className="error-title">Cannot Generate Training Plan</div>
              <div className="error-text">
                A training plan cannot be generated because the video doesn't show a recognized sport. 
                Please upload a new video with clear athletic movement.
              </div>
            </div>

            <div style={{
              marginTop: '24px',
              padding: '24px',
              background: 'var(--bg-3)',
              borderRadius: '12px'
            }}>
              <h3 style={{ fontSize: '18px', fontWeight: '700', marginBottom: '12px' }}>
                ðŸ“‹ How to Get a Training Plan
              </h3>
              <ol style={{ 
                marginLeft: '20px',
                color: 'var(--text)',
                lineHeight: '1.8',
                fontSize: '14px'
              }}>
                <li>Return to the Upload tab</li>
                <li>Upload a video showing one of the supported sports</li>
                <li>Ensure the person is fully visible in frame</li>
                <li>Complete the analysis</li>
                <li>Return to this tab for personalized training recommendations</li>
              </ol>
            </div>
          </div>
        );
      }

      const trainingPlans = {
        'long-jump': {
          exercises: [
            'Sprint approach practice: 30-40m acceleration drills with focus on final 6 strides',
            'Single-leg bounding: 3 sets Ã— 20m for explosive power development',
            'Penultimate step drills: Practice lowering center of mass before takeoff',
            'Core strengthening: Planks, side planks, and rotational exercises (3Ã—45s)',
            'Plyometric box jumps: 3 sets Ã— 8 reps at varying heights (30-60cm)',
            'Flexibility work: Hip flexor stretches and hamstring mobility (15 min daily)'
          ]
        },
        'high-jump': {
          exercises: [
            'Approach curve practice: 8-10 step approaches focusing on acceleration',
            'Vertical jump training: Depth jumps from 30-50cm boxes (3Ã—6 reps)',
            'Hip flexor flexibility: Dynamic stretches and PNF techniques',
            'Single-leg takeoff drills: Practice plant and drive mechanics',
            'Bar clearance technique: Foam bar practice for back arch and rotation',
            'Core stability: Anti-rotation exercises and hanging leg raises'
          ]
        },
        sprinting: {
          exercises: [
            'Block starts: 10Ã—20m with focus on first three steps and drive phase',
            'High knees and A-skips: 4Ã—30m for proper running mechanics',
            'Flying 30m sprints: Build to max velocity (6-8 reps with full recovery)',
            'Resistance training: Sled pulls at 10-15% bodyweight (5Ã—20m)',
            'Stride frequency drills: Fast feet exercises and wicket runs',
            'Strength training: Squats, deadlifts, and single-leg exercises (2-3x/week)'
          ]
        },
        basketball: {
          exercises: [
            'Form shooting: 100 close-range shots focusing on BEEF technique',
            'Vertical jump training: Box jumps and depth jumps (3Ã—8-10 reps)',
            'Shooting off the catch: Partner passing drills with immediate release',
            'Balance and landing: Single-leg stability exercises',
            'Core strengthening: Medicine ball rotational throws',
            'Game-speed shooting: Move and shoot drills from various spots'
          ]
        },
        soccer: {
          exercises: [
            'Plant foot positioning: Practice striking with proper non-kicking foot placement',
            'Instep drive practice: 50 repetitions focusing on contact point and follow-through',
            'Cone dribbling: Weave through cones with both feet (5Ã—30m)',
            'First touch control: Wall passes and partner exercises',
            'Power development: Leg strength training and explosive movements',
            'Accuracy training: Target practice from various distances and angles'
          ]
        },
        tennis: {
          exercises: [
            'Shadow swings: 50 slow-motion serves focusing on trophy position',
            'Fed ball drills: Partner-fed serves to practice contact point',
            'Lateral shuffles: Court movement and recovery steps (3Ã—30s)',
            'Sprint and recover: Explosive starts followed by quick stops',
            'Rotational power: Medicine ball exercises for trunk rotation',
            'Shoulder strengthening: Resistance band exercises for injury prevention'
          ]
        },
        running: {
          exercises: [
            'Cadence drills: Metronome at 180 spm for 10-minute intervals',
            'High knees & butt kicks: 4Ã—30m for running mechanics',
            'Tempo runs: 20-30 minutes at comfortably hard pace',
            'Hill repeats: 6-8Ã—200m uphill for strength and power',
            'Stride work: 6-8Ã—100m at 90% effort with full recovery',
            'Core routine: Daily planks, bridges, and stability exercises'
          ]
        },
        golf: {
          exercises: [
            'Slow-motion swings: 50 reps focusing on proper sequence and positions',
            'Alignment practice: Set up drills with alignment sticks',
            'Balance exercises: Single-leg stability and weight transfer drills',
            'Core rotation: Medicine ball exercises and trunk flexibility',
            'Impact bag training: Proper contact position and compression',
            'Video analysis: Record and review swings regularly'
          ]
        },
        yoga: {
          exercises: [
            'Sun salutations: 5-10 rounds with focus on breath and transition',
            'Hip opening sequence: Pigeon, lizard, and frog poses (hold 2-3 min)',
            'Tree pose progressions: Work towards advanced variations',
            'Breath awareness: Pranayama practice for 10-15 minutes',
            'Balance work: Warrior III and half moon pose progressions',
            'Flexibility routine: Daily practice targeting tight areas'
          ]
        },
        volleyball: {
          exercises: [
            'Approach footwork: 4-step approach repetitions (3Ã—20 reps)',
            'Arm swing technique: Wall contact drills and resistance band work',
            'Vertical jump training: Box jumps and approach jumps (3Ã—8-10)',
            'Platform passing: 100 forearm passes against wall',
            'Core strengthening: Anti-rotation and explosive movements',
            'Timing drills: Partner toss and hit with varying sets'
          ]
        },
        baseball: {
          exercises: [
            'Rotational power drills: Medicine ball slams and throws',
            'Throwing mechanics: Long toss program 3x per week',
            'Hip rotation exercises: Resistance band work and mobility',
            'Core strengthening: Rotational exercises and anti-rotation work',
            'Batting tee work: 100 swings focusing on contact point',
            'Soft toss drills: Partner-fed balls for timing and mechanics'
          ]
        },
        gymnastics: {
          exercises: [
            'Flexibility stretching: Daily routine targeting splits and bridges',
            'Handstand holds: Wall-supported progressions (3Ã—30-60s)',
            'Core strength training: L-sits, hollow holds, and arch holds',
            'Balance beam work: Walking, turns, and basic acrobatic elements',
            'Strength conditioning: Push-ups, pull-ups, and dips progressions',
            'Landing practice: Proper technique for all dismounts and tumbling'
          ]
        }
      };

      const plan = trainingPlans[results.sport] || trainingPlans.running;

      return (
        <div>
          <h2 className="module-title">Personalized Training Plan</h2>
          <p className="module-subtitle">
            Customized exercises for {results.sportName}
          </p>

          <div style={{ 
            padding: '24px',
            background: 'var(--bg-3)',
            borderRadius: '12px',
            marginBottom: '32px'
          }}>
            <h3 style={{ fontSize: '20px', fontWeight: '700', marginBottom: '12px' }}>
              Your Current Level
            </h3>
            <div style={{ fontSize: '16px', lineHeight: '1.6' }}>
              <strong>Score: {results.score}/100</strong><br />
              <div style={{ marginTop: '8px', color: 'var(--text)' }}>
                {results.score >= 85 
                  ? 'ðŸ† Elite level - You\'re performing at a high standard! Focus on maintaining consistency and refining the smallest details for peak performance.' 
                  : results.score >= 70 
                  ? 'â­ Advanced technique - You have a solid foundation. Small refinements in form and power will push you to the next level.' 
                  : results.score >= 60 
                  ? 'ðŸ’ª Good foundation - You\'re on the right track! Consistent training following this plan will yield significant improvements.' 
                  : 'ðŸŒ± Developing skills - Focus on the fundamentals. With dedicated practice, you\'ll see rapid improvement in the coming weeks!'}
              </div>
            </div>
          </div>

          <div className="insight-card" style={{ 
            background: 'var(--bg-3)' 
          }}>
            <div className="insight-icon">ðŸŽ¯</div>
            <div className="insight-content">
              <div className="insight-title">Recommended Training Schedule</div>
              <div className="insight-text">
                Complete these exercises 4-5 times per week for optimal results. Allow 48 hours between intense sessions for recovery.
              </div>
            </div>
          </div>

          <ul style={{ 
            listStyle: 'none', 
            padding: '0', 
            marginTop: '24px',
            display: 'grid',
            gap: '12px'
          }}>
            {plan.exercises.map((exercise, i) => (
              <li key={i} style={{
                padding: '16px 20px',
                background: 'var(--bg-2)',
                borderRadius: '8px',
                border: '1px solid var(--border)',
                display: 'flex',
                alignItems: 'flex-start',
                gap: '12px',
                transition: 'all 0.3s ease'
              }}>
                <span style={{ 
                  fontSize: '20px', 
                  color: 'var(--success)',
                  flexShrink: 0,
                  marginTop: '2px'
                }}>
                  âœ“
                </span>
                <span style={{ 
                  fontSize: '14px', 
                  color: 'var(--text)',
                  lineHeight: '1.6'
                }}>
                  {exercise}
                </span>
              </li>
            ))}
          </ul>

          <div className="insight-card" style={{
            background: 'rgba(170,255,0,0.07)', border: '1px solid rgba(170,255,0,0.2)',
            marginTop: '24px'
          }}>
            <div className="insight-icon">ðŸ“ˆ</div>
            <div className="insight-content">
              <div className="insight-title">Progress Projection</div>
              <div className="insight-text">
                With consistent training following this plan, expect a 10-15 point score improvement in 6-8 weeks. 
                Upload weekly videos to track your progress and receive updated recommendations!
              </div>
            </div>
          </div>

          <div style={{
            marginTop: '32px',
            padding: '24px',
            background: 'rgba(255,184,0,0.07)', border: '1px solid rgba(255,184,0,0.2)',
            borderRadius: '12px'
          }}>
            <h3 style={{ fontSize: '18px', fontWeight: '700', marginBottom: '12px' }}>
              âš ï¸ Important Training Tips
            </h3>
            <ul style={{ 
              marginLeft: '20px',
              color: 'var(--text)',
              lineHeight: '1.8',
              fontSize: '14px'
            }}>
              <li>Always warm up for 10-15 minutes before training</li>
              <li>Focus on quality over quantity - proper form is essential</li>
              <li>Stay hydrated and maintain proper nutrition</li>
              <li>Get adequate sleep (7-9 hours) for recovery</li>
              <li>Listen to your body - rest if experiencing pain</li>
              <li>Video record your sessions to monitor progress</li>
            </ul>
          </div>
        </div>
      );
    }

    // Progress Module
    function ProgressModule({ history, onClear }) {
      const { useState: useLocalState } = React;
      const [filterSport, setFilterSport] = useLocalState('all');

      const filtered = filterSport === 'all' ? history : history.filter(s => s.sport === filterSport);
      const sports = [...new Set(history.map(s => s.sport))];

      const maxScore = 100;
      const chartH = 160;
      const chartW = Math.max(filtered.length * 52, 300);

      if (history.length === 0) {
        return (
          <div style={{ textAlign: 'center', padding: '48px 24px' }}>
            <div style={{ fontSize: '64px', marginBottom: '16px' }}>ðŸ“ˆ</div>
            <h2 className="module-title" style={{ textAlign: 'center' }}>Progress Tracking</h2>
            <p style={{ color: 'var(--text-dim)', marginTop: '12px', fontSize: '16px' }}>
              Complete your first analysis to start tracking your progress over time.
            </p>
          </div>
        );
      }

      return (
        <div>
          <h2 className="module-title">Progress Tracking</h2>
          <p className="module-subtitle">Your performance across {history.length} session{history.length !== 1 ? 's' : ''}</p>

          {/* Sport filter */}
          {sports.length > 1 && (
            <div style={{ display: 'flex', gap: '8px', flexWrap: 'wrap', marginBottom: '24px' }}>
              {['all', ...sports].map(s => (
                <button key={s} onClick={() => setFilterSport(s)}
                  style={{
                    padding: '6px 14px', borderRadius: '20px', border: '2px solid',
                    borderColor: filterSport === s ? 'var(--primary)' : 'var(--border)',
                    background: filterSport === s ? 'var(--primary)' : 'var(--bg-3)',
                    color: filterSport === s ? 'var(--bg)' : 'var(--text-dim)',
                    fontWeight: '600', fontSize: '13px', cursor: 'pointer'
                  }}>
                  {s === 'all' ? 'ðŸ… All Sports' : (SPORT_PATTERNS[s]?.emoji + ' ' + (SPORT_PATTERNS[s]?.name || s))}
                </button>
              ))}
            </div>
          )}

          {/* Score chart */}
          <div style={{ background: 'var(--bg-2)', borderRadius: '12px', border: '1px solid var(--border)', padding: '24px', marginBottom: '24px', overflowX: 'auto' }}>
            <h3 style={{ fontSize: '16px', fontWeight: '700', marginBottom: '16px' }}>Score Over Time</h3>
            <svg width={chartW} height={chartH + 50} style={{ display: 'block' }}>
              {/* Grid lines */}
              {[0, 25, 50, 75, 100].map(v => (
                <g key={v}>
                  <line x1="40" y1={chartH - (v / maxScore) * chartH} x2={chartW} y2={chartH - (v / maxScore) * chartH}
                    stroke="rgba(255,255,255,0.06)" strokeWidth="1" />
                  <text x="32" y={chartH - (v / maxScore) * chartH + 4} textAnchor="end"
                    style={{ fontSize: '11px', fill: 'var(--text-muted)' }}>{v}</text>
                </g>
              ))}
              {/* Line path */}
              {filtered.length > 1 && (
                <polyline
                  points={filtered.map((s, i) => `${44 + i * 52},${chartH - (s.score / maxScore) * chartH}`).join(' ')}
                  fill="none" stroke="var(--primary)" strokeWidth="2.5" strokeLinejoin="round" />
              )}
              {/* Dots + labels */}
              {filtered.map((s, i) => {
                const x = 44 + i * 52;
                const y = chartH - (s.score / maxScore) * chartH;
                const color = s.score >= 80 ? '#10B981' : s.score >= 60 ? '#F59E0B' : '#EF4444';
                return (
                  <g key={s.id}>
                    <circle cx={x} cy={y} r="6" fill={color} stroke="white" strokeWidth="2" />
                    <text x={x} y={y - 12} textAnchor="middle" style={{ fontSize: '11px', fontWeight: '700', fill: color }}>{s.score}</text>
                    <text x={x} y={chartH + 18} textAnchor="middle" style={{ fontSize: '10px', fill: 'var(--text-dim)' }}>{s.date.split('/').slice(0,2).join('/')}</text>
                    <text x={x} y={chartH + 32} textAnchor="middle" style={{ fontSize: '10px', fill: 'var(--text-muted)' }}>{SPORT_PATTERNS[s.sport]?.emoji}</text>
                  </g>
                );
              })}
            </svg>
          </div>

          {/* Best & Latest stats */}
          <div className="grid-3" style={{ marginBottom: '24px' }}>
            {[
              { label: 'Best Score', value: Math.max(...filtered.map(s => s.score)), color: 'var(--success)' },
              { label: 'Latest Score', value: filtered[filtered.length - 1]?.score, color: 'var(--primary)' },
              { label: 'Improvement', value: filtered.length > 1 ? `${filtered[filtered.length-1].score - filtered[0].score > 0 ? '+' : ''}${filtered[filtered.length-1].score - filtered[0].score}` : 'â€”', color: filtered.length > 1 && filtered[filtered.length-1].score >= filtered[0].score ? 'var(--success)' : 'var(--error)' }
            ].map(stat => (
              <div key={stat.label} className="metric-card" style={{ textAlign: 'center' }}>
                <div className="metric-label">{stat.label}</div>
                <div className="metric-value" style={{ color: stat.color }}>{stat.value}</div>
              </div>
            ))}
          </div>

          {/* Session list */}
          <div style={{ background: 'var(--bg-2)', borderRadius: '12px', border: '1px solid var(--border)', overflow: 'hidden' }}>
            <div style={{ padding: '16px 20px', borderBottom: '1px solid var(--border)', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
              <h3 style={{ fontSize: '16px', fontWeight: '700' }}>Session History</h3>
              <button onClick={onClear} style={{ fontSize: '12px', color: 'var(--error)', background: 'none', border: 'none', cursor: 'pointer', fontWeight: '600' }}>
                ðŸ—‘ Clear All
              </button>
            </div>
            {[...filtered].reverse().map((s, i) => (
              <div key={s.id} style={{ padding: '14px 20px', borderBottom: i < filtered.length - 1 ? '1px solid var(--border)' : 'none', display: 'flex', alignItems: 'center', gap: '14px' }}>
                <div style={{ fontSize: '28px' }}>{SPORT_PATTERNS[s.sport]?.emoji || 'ðŸ…'}</div>
                <div style={{ flex: 1 }}>
                  <div style={{ fontWeight: '700', fontSize: '14px' }}>{s.sportName}</div>
                  <div style={{ fontSize: '12px', color: 'var(--text-dim)' }}>{s.date} Â· {s.time}</div>
                </div>
                <div style={{ fontWeight: '800', fontSize: '22px', color: s.score >= 80 ? 'var(--success)' : s.score >= 60 ? 'var(--warning)' : 'var(--error)' }}>
                  {s.score}
                </div>
              </div>
            ))}
          </div>
        </div>
      );
    }

    // Compare Module â€” side-by-side with reference athlete descriptions
    function CompareModule({ results }) {
      const { useState: useLocalState } = React;
      const sport = results?.sport;
      const pattern = sport && SPORT_PATTERNS[sport];

      const PRO_BENCHMARKS = {
        'long-jump': { name: 'Elite Long Jumper', scores: { form: 95, power: 92, consistency: 88, balance: 90, timing: 93 }, tips: ['Knee angle 160-170Â° at takeoff', 'Hip extension >165Â° during flight', 'Arms drive explosively upward'] },
        'high-jump': { name: 'Elite High Jumper', scores: { form: 94, power: 90, consistency: 87, balance: 92, timing: 91 }, tips: ['Curved approach for centripetal force', 'Bar-clearance arch >50Â° back bend', 'Lead knee drives up forcefully'] },
        sprinting:   { name: 'Elite Sprinter', scores: { form: 96, power: 94, consistency: 92, balance: 88, timing: 95 }, tips: ['Hip angle 175-185Â° at max velocity', 'Arm swing 60-90Â° elbow angle', 'Ground contact < 100ms at top speed'] },
        basketball:  { name: 'NBA Shooter', scores: { form: 93, power: 85, consistency: 95, balance: 90, timing: 88 }, tips: ['Release angle 50-55Â° above horizontal', 'Elbow directly under ball at set point', 'Follow-through holds until ball clears rim'] },
        soccer:      { name: 'Pro Soccer Player', scores: { form: 92, power: 91, consistency: 89, balance: 88, timing: 90 }, tips: ['Plant foot 15cm beside ball', 'Hip rotation 70-80Â° through contact', 'Follow-through reaches 40-50Â°'] },
        tennis:      { name: 'Pro Tennis Server', scores: { form: 94, power: 92, consistency: 90, balance: 87, timing: 93 }, tips: ['Trophy position: elbow at shoulder height', 'Ball toss 30-40cm above contact point', 'Racket head speed 100+ mph at contact'] },
        running:     { name: 'Elite Distance Runner', scores: { form: 91, power: 82, consistency: 96, balance: 90, timing: 92 }, tips: ['Cadence 175-185 spm', 'Forward lean 5-10Â° from vertical', 'Foot strike under centre of gravity'] },
        golf:        { name: 'Tour Pro Golfer', scores: { form: 96, power: 88, consistency: 94, balance: 93, timing: 90 }, tips: ['Hip rotation 45Â° at impact', 'Spine angle maintained throughout swing', 'Wrist lag held to impact zone'] },
        yoga:        { name: 'Advanced Yogi', scores: { form: 97, power: 70, consistency: 95, balance: 96, timing: 88 }, tips: ['Neutral spine alignment', 'Hip stacking in standing poses', 'Breath-to-movement ratio 1:1'] },
        volleyball:  { name: 'Pro Volleyball Player', scores: { form: 93, power: 91, consistency: 88, balance: 89, timing: 94 }, tips: ['Approach jump: 4-step timing', 'Arm swing shoulder-to-wrist acceleration', 'Contact point at full arm extension'] },
        baseball:    { name: 'MLB Hitter', scores: { form: 94, power: 93, consistency: 89, balance: 91, timing: 95 }, tips: ['Hip rotation 80-90Â° before contact', 'Bat speed > 70 mph at contact', 'Weight transfer back-to-front at 60%'] },
        gymnastics:  { name: 'Elite Gymnast', scores: { form: 97, power: 88, consistency: 93, balance: 95, timing: 92 }, tips: ['Body tension throughout movements', 'Pointed toes and straight knees', 'Hollow vs arch body control'] }
      };

      const pro = PRO_BENCHMARKS[sport] || null;
      if (!pro || !results) return null;

      const categories = Object.keys(results.scores);

      return (
        <div style={{ marginTop: '32px' }}>
          <div style={{ background:'var(--bg-3)', borderRadius: '12px', padding: '24px', marginBottom: '24px' }}>
            <h3 style={{ fontSize: '20px', fontWeight: '700', marginBottom: '4px' }}>âš”ï¸ Pro Comparison</h3>
            <p style={{ color: 'var(--text-dim)', fontSize: '14px' }}>You vs {pro.name}</p>
          </div>

          {/* Comparison bars */}
          <div style={{ display: 'grid', gap: '16px', marginBottom: '24px' }}>
            {categories.map(cat => {
              const yours = results.scores[cat];
              const theirs = pro.scores[cat];
              const gap = theirs - yours;
              return (
                <div key={cat} style={{ background: 'var(--bg-2)', borderRadius: '10px', border: '1px solid var(--border)', padding: '16px' }}>
                  <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '10px' }}>
                    <span style={{ fontWeight: '700', fontSize: '14px', textTransform: 'capitalize' }}>{cat}</span>
                    <span style={{ fontSize: '13px', color: gap > 0 ? 'var(--error)' : 'var(--success)', fontWeight: '700' }}>
                      {gap > 0 ? `âˆ’${gap} pts behind` : `+${Math.abs(gap)} pts ahead`}
                    </span>
                  </div>
                  <div style={{ display: 'flex', gap: '8px', alignItems: 'center', marginBottom: '6px' }}>
                    <span style={{ fontSize: '11px', color: 'var(--text-dim)', width: '32px' }}>You</span>
                    <div style={{ flex: 1, height: '8px', background: 'rgba(255,255,255,0.06)', borderRadius: '4px', overflow: 'hidden' }}>
                      <div style={{ height: '100%', width: `${yours}%`, background: 'var(--primary)', borderRadius: '5px', transition: 'width 1s' }} />
                    </div>
                    <span style={{ fontSize: '12px', fontWeight: '700', color: 'var(--primary)', width: '28px', textAlign: 'right' }}>{yours}</span>
                  </div>
                  <div style={{ display: 'flex', gap: '8px', alignItems: 'center' }}>
                    <span style={{ fontSize: '11px', color: 'var(--text-dim)', width: '32px' }}>Pro</span>
                    <div style={{ flex: 1, height: '8px', background: 'rgba(255,255,255,0.06)', borderRadius: '4px', overflow: 'hidden' }}>
                      <div style={{ height: '100%', width: `${theirs}%`, background: '#6366F1', borderRadius: '5px', transition: 'width 1s' }} />
                    </div>
                    <span style={{ fontSize: '12px', fontWeight: '700', color: '#6366F1', width: '28px', textAlign: 'right' }}>{theirs}</span>
                  </div>
                </div>
              );
            })}
          </div>

          {/* Pro technique cues */}
          <div style={{ background:'var(--bg-3)', borderRadius: '12px', padding: '20px' }}>
            <h4 style={{ fontSize: '16px', fontWeight: '700', marginBottom: '12px' }}>ðŸŽ¯ {pro.name}'s Key Technique Cues</h4>
            <div style={{ display: 'grid', gap: '10px' }}>
              {pro.tips.map((tip, i) => (
                <div key={i} style={{ display: 'flex', gap: '10px', alignItems: 'flex-start' }}>
                  <span style={{ background: 'var(--primary)', color: 'var(--bg)', borderRadius: '50%', width: '22px', height: '22px', display: 'flex', alignItems: 'center', justifyContent: 'center', fontSize: '11px', fontWeight: '700', flexShrink: 0, marginTop: '1px' }}>{i+1}</span>
                  <span style={{ fontSize: '14px', color: 'var(--text)', lineHeight: '1.5' }}>{tip}</span>
                </div>
              ))}
            </div>
          </div>
        </div>
      );
    }

    // â”€â”€ LIVE DETECTION MODULE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function LiveDetectionModule({ athleteProfile }) {
      const { useState: useLS, useEffect: useLE, useRef: useLR } = React;

      const videoRef  = useLR(null);
      const canvasRef = useLR(null);
      const streamRef = useLR(null);
      const poseRef   = useLR(null);
      const rafRef    = useLR(null);
      const framesBuf = useLR([]);   // rolling 90-frame buffer
      const scoreTimerRef = useLR(null);

      const [status, setStatus]           = useLS('idle');   // idle | loading | running | error
      const [liveScores, setLiveScores]   = useLS(null);
      const [liveSport, setLiveSport]     = useLS(null);
      const [liveMetrics, setLiveMetrics] = useLS(null);
      const [fps, setFps]                 = useLS(0);
      const [landmark, setLandmark]       = useLS(false);    // are landmarks being detected?
      const [errMsg, setErrMsg]           = useLS('');
      const fpsCounter = useLR({ last: Date.now(), count: 0 });

      // Joint connections for skeleton
      const CONNECTIONS = [
        [11,12],[11,13],[13,15],[12,14],[14,16],
        [11,23],[12,24],[23,24],
        [23,25],[25,27],[27,29],[27,31],[24,26],[26,28],[28,30],[28,32],
        [15,17],[15,19],[16,18],[16,20]
      ];

      const drawSkeleton = (ctx, landmarks, w, h) => {
        // Glow connections
        ctx.shadowBlur = 8;
        ctx.shadowColor = 'rgba(0,229,255,0.6)';
        ctx.strokeStyle = 'rgba(0,229,255,0.9)';
        ctx.lineWidth = 3;
        CONNECTIONS.forEach(([a, b]) => {
          const lA = landmarks[a], lB = landmarks[b];
          if (!lA || !lB || lA.visibility < 0.4 || lB.visibility < 0.4) return;
          ctx.beginPath();
          ctx.moveTo(lA.x * w, lA.y * h);
          ctx.lineTo(lB.x * w, lB.y * h);
          ctx.stroke();
        });
        // Joints
        ctx.shadowBlur = 12;
        landmarks.forEach((lm, i) => {
          if (lm.visibility < 0.4) return;
          ctx.beginPath();
          const r = i === 0 ? 7 : 5;
          ctx.arc(lm.x * w, lm.y * h, r, 0, Math.PI * 2);
          ctx.fillStyle = i === 0 ? '#FFD700' : '#00E5FF';
          ctx.shadowColor = i === 0 ? 'rgba(255,215,0,0.8)' : 'rgba(0,229,255,0.8)';
          ctx.fill();
        });
        ctx.shadowBlur = 0;
      };

      const drawHUD = (ctx, w, h, sport, scores, metrics, fpsVal, hasLandmarks) => {
        // Top bar
        ctx.fillStyle = 'rgba(8,12,20,0.75)';
        ctx.fillRect(0, 0, w, 52);

        // REC dot
        ctx.beginPath();
        ctx.arc(20, 26, 7, 0, Math.PI * 2);
        ctx.fillStyle = '#FF3D71';
        ctx.fill();
        ctx.fillStyle = '#FF3D71';
        ctx.font = 'bold 13px JetBrains Mono, monospace';
        ctx.fillText('LIVE', 34, 31);

        // FPS
        ctx.fillStyle = fpsVal >= 20 ? '#AAFF00' : '#FFB800';
        ctx.font = 'bold 13px JetBrains Mono, monospace';
        ctx.fillText(`${fpsVal} FPS`, w - 80, 31);

        // Landmark status
        ctx.fillStyle = hasLandmarks ? '#00E5FF' : '#6B7A96';
        ctx.font = 'bold 12px JetBrains Mono, monospace';
        ctx.fillText(hasLandmarks ? 'â— POSE DETECTED' : 'â—‹ SEARCHING...', w / 2 - 70, 31);

        if (!sport || !scores) return;

        // Sport badge
        const sportPattern = Object.values(SPORT_PATTERNS).find(p => p.name === sport);
        const emoji = sportPattern ? sportPattern.emoji : 'ðŸ…';

        ctx.fillStyle = 'rgba(8,12,20,0.8)';
        ctx.fillRect(0, h - 160, w, 160);

        // Sport label
        ctx.fillStyle = '#00E5FF';
        ctx.font = 'bold 16px Bebas Neue, sans-serif';
        ctx.letterSpacing = '2px';
        ctx.fillText(`${emoji}  ${sport.toUpperCase()}`, 20, h - 125);
        ctx.letterSpacing = '0px';

        // Score bars
        if (scores) {
          const cats = Object.entries(scores);
          const barW = (w - 40) / cats.length - 10;
          cats.forEach(([cat, val], i) => {
            const bx = 20 + i * (barW + 10);
            const by = h - 110;
            const bh = 70;

            // Background bar
            ctx.fillStyle = 'rgba(255,255,255,0.06)';
            ctx.beginPath();
            ctx.roundRect(bx, by, barW, bh, 4);
            ctx.fill();

            // Fill bar
            const fillH = (val / 100) * bh;
            const color = val >= 80 ? '#AAFF00' : val >= 60 ? '#FFB800' : '#FF3D71';
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.roundRect(bx, by + bh - fillH, barW, fillH, 4);
            ctx.fill();

            // Label
            ctx.fillStyle = '#6B7A96';
            ctx.font = '10px DM Sans, sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(cat.toUpperCase().slice(0, 5), bx + barW / 2, by + bh + 14);

            // Value
            ctx.fillStyle = color;
            ctx.font = 'bold 13px JetBrains Mono, monospace';
            ctx.fillText(val, bx + barW / 2, by + bh - 4);
            ctx.textAlign = 'left';
          });
        }

        // Overall score ring â€” right side
        if (scores) {
          const overall = Math.round(Object.values(scores).reduce((a,b)=>a+b,0)/Object.values(scores).length);
          const rx = w - 80, ry = h - 90, rr = 40;
          ctx.beginPath();
          ctx.arc(rx, ry, rr, 0, Math.PI * 2);
          ctx.strokeStyle = 'rgba(255,255,255,0.08)';
          ctx.lineWidth = 6;
          ctx.stroke();
          const angle = (overall / 100) * Math.PI * 2 - Math.PI / 2;
          ctx.beginPath();
          ctx.arc(rx, ry, rr, -Math.PI / 2, angle);
          ctx.strokeStyle = overall >= 80 ? '#AAFF00' : overall >= 60 ? '#FFB800' : '#FF3D71';
          ctx.lineWidth = 6;
          ctx.stroke();
          ctx.fillStyle = '#E8EDF5';
          ctx.font = 'bold 18px JetBrains Mono, monospace';
          ctx.textAlign = 'center';
          ctx.fillText(overall, rx, ry + 6);
          ctx.font = '9px DM Sans, sans-serif';
          ctx.fillStyle = '#6B7A96';
          ctx.fillText('SCORE', rx, ry + 20);
          ctx.textAlign = 'left';
        }
      };

      // Reuse the angle + average helpers from the parent scope via globals
      const calcAngle = (a, b, c) => {
        if (!a || !b || !c) return NaN;
        const rad = Math.atan2(c.y-b.y, c.x-b.x) - Math.atan2(a.y-b.y, a.x-b.x);
        let ang = Math.abs(rad * 180 / Math.PI);
        if (ang > 180) ang = 360 - ang;
        return Math.max(0, Math.min(180, ang));
      };
      const avg = arr => {
        if (!arr || !arr.length) return 0;
        const v = arr.filter(x => isFinite(x) && !isNaN(x));
        return v.length ? v.reduce((a,b)=>a+b,0)/v.length : 0;
      };

      const computeLiveScores = (frames) => {
        if (!frames || frames.length < 5) return null;

        const kneeAngles=[], hipAngles=[], armAngles=[], speeds=[], balances=[];

        frames.forEach((lm, i) => {
          if (!lm) return;
          const [rA,rK,rH,lA2,lK2,lH2,rS,lS,rW,rE,lW,lE] =
            [lm[28],lm[26],lm[24],lm[27],lm[25],lm[23],lm[12],lm[11],lm[16],lm[14],lm[15],lm[13]];

          const a1 = calcAngle(rA,rK,rH); if(isFinite(a1)) kneeAngles.push(a1);
          const a2 = calcAngle(lA2,lK2,lH2); if(isFinite(a2)) kneeAngles.push(a2);
          const a3 = calcAngle(rK,rH,rS); if(isFinite(a3)) hipAngles.push(a3);
          const a4 = calcAngle(lK2,lH2,lS); if(isFinite(a4)) hipAngles.push(a4);
          const a5 = calcAngle(rW,rE,rS); if(isFinite(a5)) armAngles.push(a5);
          const a6 = calcAngle(lW,lE,lS); if(isFinite(a6)) armAngles.push(a6);

          if (i > 0 && frames[i-1] && rH && lm[23]) {
            const prevRH = frames[i-1][24], prevLH = frames[i-1][23];
            if (prevRH && prevLH) {
              const dx = ((rH.x+lm[23].x)/2) - ((prevRH.x+prevLH.x)/2);
              const dy = ((rH.y+lm[23].y)/2) - ((prevRH.y+prevLH.y)/2);
              const sp = Math.sqrt(dx*dx+dy*dy)*30*10;
              if (sp < 100) speeds.push(sp);
            }
          }
          if (lm[27] && lm[28] && lm[27].visibility>0.4 && lm[28].visibility>0.4) {
            balances.push(Math.max(0, 100 - Math.abs(lm[27].y-lm[28].y)*100));
          }
        });

        const avgKnee = avg(kneeAngles);
        const avgHip  = avg(hipAngles);
        const avgArm  = avg(armAngles);
        const avgSpd  = avg(speeds);
        const avgBal  = avg(balances);

        // Detect sport via pattern matching
        let bestSport = null, bestScore = 0;
        Object.entries(SPORT_PATTERNS).forEach(([key, pat]) => {
          const kp = pat.keyPoints;
          let s = 0, w = 0;
          const scoreAngle = (val, min, max, opt) => {
            if (!val) return 50;
            if (val >= min && val <= max) return Math.max(60, 100 - (Math.abs(val-opt)/(max-min))*50);
            return Math.max(35, 65 - Math.abs(val < min ? min-val : val-max)*0.3);
          };
          s += scoreAngle(avgKnee, kp.ankleKneeAngle.min, kp.ankleKneeAngle.max, kp.ankleKneeAngle.optimal) * pat.weights.form;
          w += pat.weights.form;
          s += scoreAngle(avgHip, kp.hipAngle.min, kp.hipAngle.max, kp.hipAngle.optimal) * pat.weights.form;
          w += pat.weights.form;
          s += scoreAngle(avgArm, kp.armSwing.min, kp.armSwing.max, kp.armSwing.optimal) * pat.weights.form * 0.5;
          w += pat.weights.form * 0.5;
          const spRatio = avgSpd / (kp.speedRequirement || 1);
          const spScore = spRatio > 0.1 ? Math.min(100, 55 + spRatio * 10) : 50;
          s += spScore * pat.weights.power;
          w += pat.weights.power;
          s += (avgBal > 0 ? Math.min(100, avgBal * 1.2 + 5) : 65) * pat.weights.balance;
          w += pat.weights.balance;
          const total = w > 0 ? s / w : 0;
          if (total > bestScore) { bestScore = total; bestSport = key; }
        });

        if (!bestSport || bestScore < 20) return null;

        const pat = SPORT_PATTERNS[bestSport];
        const kp = pat.keyPoints;
        const scoreA = (v, mn, mx, op) => {
          if (!v) return 60;
          if (v>=mn && v<=mx) return Math.max(60, 100-(Math.abs(v-op)/(mx-mn))*40);
          return Math.max(50, 65-Math.abs(v<mn?mn-v:v-mx)*0.25);
        };
        const spRat = avgSpd/(kp.speedRequirement||1);
        const pwrScore = spRat>0.1 ? Math.min(100, 55+spRat*12) : 55;
        const cons = kneeAngles.length>2 ? (() => {
          const m = avg(kneeAngles);
          const sd = Math.sqrt(avg(kneeAngles.map(v=>(v-m)**2)));
          return Math.max(0, Math.min(100, 100-(sd/m)*100*1.2+10));
        })() : 65;
        const tim = avg(kneeAngles.slice(1).map((v,i)=>Math.max(0, 100-Math.abs(v-kneeAngles[i])*1.2)));

        return {
          sport: pat.name,
          sportKey: bestSport,
          confidence: Math.round(bestScore),
          scores: {
            form:        Math.round((scoreA(avgKnee,kp.ankleKneeAngle.min,kp.ankleKneeAngle.max,kp.ankleKneeAngle.optimal)*0.4+scoreA(avgHip,kp.hipAngle.min,kp.hipAngle.max,kp.hipAngle.optimal)*0.4+scoreA(avgArm,kp.armSwing.min,kp.armSwing.max,kp.armSwing.optimal)*0.2)),
            power:       Math.round(Math.min(100, pwrScore)),
            consistency: Math.round(Math.min(100, cons)),
            balance:     Math.round(Math.min(100, avgBal>0?avgBal*1.3+10:65)),
            timing:      Math.round(Math.min(100, tim>0?tim*1.3+10:65)),
          },
          metrics: {
            knee: Math.round(avgKnee), hip: Math.round(avgHip),
            arm: Math.round(avgArm), speed: avgSpd.toFixed(2), balance: Math.round(avgBal)
          }
        };
      };

      const startLive = async () => {
        setStatus('loading');
        setErrMsg('');
        try {
          const stream = await navigator.mediaDevices.getUserMedia({
            video: { width:{ideal:1280}, height:{ideal:720}, facingMode:'user' },
            audio: false
          });
          streamRef.current = stream;
          const vid = videoRef.current;
          vid.srcObject = stream;
          await vid.play();

          const pose = new window.Pose({
            locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.5.1675469404/${f}`
          });
          pose.setOptions({ modelComplexity: 1, smoothLandmarks: true,
            minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });

          pose.onResults(res => {
            const cv = canvasRef.current;
            const v  = videoRef.current;
            if (!cv || !v) return;

            cv.width  = v.videoWidth  || 640;
            cv.height = v.videoHeight || 480;
            const ctx = cv.getContext('2d');

            // Mirror the video feed
            ctx.save();
            ctx.scale(-1, 1);
            ctx.drawImage(v, -cv.width, 0, cv.width, cv.height);
            ctx.restore();

            const hasLm = !!(res.poseLandmarks && res.poseLandmarks.length > 0);
            setLandmark(hasLm);

            if (hasLm) {
              // Mirror landmarks for display
              const mirrored = res.poseLandmarks.map(lm => ({...lm, x: 1 - lm.x}));
              drawSkeleton(ctx, mirrored, cv.width, cv.height);
              framesBuf.current.push(res.poseLandmarks);
              if (framesBuf.current.length > 90) framesBuf.current.shift();
            }

            // FPS counter
            fpsCounter.current.count++;
            const now = Date.now();
            if (now - fpsCounter.current.last >= 1000) {
              setFps(fpsCounter.current.count);
              fpsCounter.current.count = 0;
              fpsCounter.current.last = now;
            }

            // Draw HUD with latest scores
            setLiveScores(prev => {
              drawHUD(ctx, cv.width, cv.height,
                liveSport, prev, liveMetrics, fps, hasLm);
              return prev;
            });
          });

          poseRef.current = pose;

          const loop = async () => {
            const v2 = videoRef.current;
            if (!streamRef.current || !v2) return;
            if (v2.readyState >= 2) {
              try { await pose.send({ image: v2 }); } catch(e) {}
            }
            rafRef.current = requestAnimationFrame(loop);
          };
          loop();

          // Score update every 1.5 seconds
          scoreTimerRef.current = setInterval(() => {
            const buf = framesBuf.current;
            if (buf.length < 5) return;
            const result = computeLiveScores(buf);
            if (result) {
              setLiveSport(result.sport);
              setLiveScores(result.scores);
              setLiveMetrics(result.metrics);
            }
          }, 1500);

          setStatus('running');
        } catch (e) {
          setErrMsg(e.message || 'Camera access denied.');
          setStatus('error');
        }
      };

      const stopLive = () => {
        if (rafRef.current) cancelAnimationFrame(rafRef.current);
        if (scoreTimerRef.current) clearInterval(scoreTimerRef.current);
        if (poseRef.current) { try { poseRef.current.close(); } catch(e){} poseRef.current = null; }
        if (streamRef.current) { streamRef.current.getTracks().forEach(t=>t.stop()); streamRef.current = null; }
        framesBuf.current = [];
        setStatus('idle');
        setLiveScores(null);
        setLiveSport(null);
        setLiveMetrics(null);
        setLandmark(false);
        setFps(0);
      };

      useLE(() => () => stopLive(), []);

      const scoreColor = v => v >= 80 ? '#AAFF00' : v >= 60 ? '#FFB800' : '#FF3D71';
      const overall = liveScores
        ? Math.round(Object.values(liveScores).reduce((a,b)=>a+b,0)/Object.values(liveScores).length)
        : null;

      return (
        <div>
          <h2 className="module-title">ðŸ”´ Live Detection</h2>
          <p className="module-subtitle">Real-time pose analysis and sport detection â€” no upload needed</p>

          {/* Camera Feed */}
          <div style={{
            position:'relative', borderRadius:'16px', overflow:'hidden',
            background:'#000', border:'1px solid var(--border)',
            marginBottom:'20px',
            minHeight: status === 'idle' || status === 'error' ? '0' : '420px',
            display: status === 'idle' || status === 'error' ? 'none' : 'block'
          }}>
            {/* Hidden video source */}
            <video ref={videoRef} autoPlay playsInline muted
              style={{ position:'absolute', opacity:0, pointerEvents:'none', width:'1px', height:'1px' }} />

            {/* Canvas is the display */}
            <canvas ref={canvasRef}
              style={{ width:'100%', display:'block', maxHeight:'560px', borderRadius:'16px' }} />

            {/* Loading overlay */}
            {status === 'loading' && (
              <div style={{
                position:'absolute', inset:0, display:'flex', alignItems:'center',
                justifyContent:'center', background:'rgba(8,12,20,0.85)', flexDirection:'column', gap:'16px'
              }}>
                <div className="spinner" />
                <span style={{color:'var(--primary)', fontWeight:'700'}}>Starting camera & pose model...</span>
              </div>
            )}
          </div>

          {/* Idle state */}
          {status === 'idle' && (
            <div style={{textAlign:'center', padding:'40px 20px'}}>
              <div style={{fontSize:'72px', marginBottom:'16px'}}>ðŸ”´</div>
              <h3 style={{fontSize:'22px', fontWeight:'700', marginBottom:'8px'}}>Real-Time Sport Detection</h3>
              <p style={{color:'var(--text-dim)', marginBottom:'28px', maxWidth:'420px', margin:'0 auto 28px', lineHeight:'1.7'}}>
                Point your camera at yourself performing any sport. SXA will detect your movements,
                overlay a skeleton, and score your technique <strong style={{color:'var(--primary)'}}>live</strong> â€” no recording needed.
              </p>
              <button className="btn btn-primary" onClick={startLive}
                style={{fontSize:'15px', padding:'14px 36px', gap:'10px'}}>
                ðŸ“· Start Live Detection
              </button>
            </div>
          )}

          {/* Error */}
          {status === 'error' && (
            <div className="error-message">
              <div className="error-icon">ðŸ“·</div>
              <div className="error-title">Camera Error</div>
              <div className="error-text">{errMsg || 'Could not access camera. Please allow camera permissions and try again.'}</div>
              <button className="btn btn-primary" onClick={startLive} style={{marginTop:'16px'}}>
                Try Again
              </button>
            </div>
          )}

          {/* Stop button */}
          {status === 'running' && (
            <div style={{display:'flex', justifyContent:'center', marginBottom:'20px'}}>
              <button className="btn" onClick={stopLive}
                style={{background:'linear-gradient(135deg,#FF3D71,#CC1144)', color:'white',
                  padding:'12px 32px', fontSize:'14px', gap:'8px'}}>
                â¹ Stop Detection
              </button>
            </div>
          )}

          {/* Live Score Panel */}
          {status === 'running' && (
            <div style={{display:'grid', gridTemplateColumns:'1fr 1fr', gap:'16px', marginBottom:'20px'}}>
              {/* Sport + Overall */}
              <div className="metric-card" style={{textAlign:'center', gridRow:'span 1'}}>
                <div className="metric-label">Detected Sport</div>
                {liveSport ? (
                  <>
                    <div style={{fontSize:'36px', margin:'8px 0'}}>
                      {SPORT_PATTERNS[Object.keys(SPORT_PATTERNS).find(k=>SPORT_PATTERNS[k].name===liveSport)]?.emoji || 'ðŸ…'}
                    </div>
                    <div style={{fontWeight:'800', fontSize:'18px', color:'var(--primary)'}}>{liveSport}</div>
                    <div style={{fontSize:'12px', color:'var(--text-dim)', marginTop:'4px', fontFamily:'var(--font-mono)'}}>
                      ANALYZING LIVE
                    </div>
                  </>
                ) : (
                  <div style={{padding:'16px 0', color:'var(--text-dim)'}}>
                    <div style={{fontSize:'28px', marginBottom:'8px'}}>ðŸ”</div>
                    <div style={{fontSize:'13px'}}>Waiting for movement...</div>
                  </div>
                )}
              </div>

              {/* Overall score */}
              <div className="metric-card" style={{textAlign:'center'}}>
                <div className="metric-label">Overall Score</div>
                {overall !== null ? (
                  <>
                    <div className="metric-value" style={{color: scoreColor(overall), fontSize:'52px'}}>{overall}</div>
                    <div style={{fontSize:'13px', color:'var(--text-dim)'}}>
                      {overall >= 80 ? 'ðŸ† Elite Form' : overall >= 65 ? 'â­ Good Technique' : 'ðŸ’ª Keep Training'}
                    </div>
                  </>
                ) : (
                  <div style={{padding:'16px 0', color:'var(--text-dim)'}}>
                    <div className="spinner" style={{margin:'0 auto'}} />
                  </div>
                )}
              </div>
            </div>
          )}

          {/* Breakdown bars */}
          {status === 'running' && liveScores && (
            <div style={{background:'var(--bg-2)', borderRadius:'14px', border:'1px solid var(--border)', padding:'20px', marginBottom:'20px'}}>
              <div style={{fontWeight:'700', fontSize:'15px', marginBottom:'16px'}}>ðŸ“Š Live Breakdown</div>
              {Object.entries(liveScores).map(([cat, val]) => (
                <div key={cat} style={{marginBottom:'14px'}}>
                  <div style={{display:'flex', justifyContent:'space-between', marginBottom:'6px'}}>
                    <span style={{fontWeight:'600', fontSize:'13px', textTransform:'capitalize'}}>{cat}</span>
                    <span style={{fontWeight:'800', fontSize:'13px', color: scoreColor(val), fontFamily:'var(--font-mono)'}}>{val}/100</span>
                  </div>
                  <div className="progress-bar">
                    <div className="progress-fill" style={{width:`${val}%`,
                      background: val>=80?'linear-gradient(90deg,#88CC00,#AAFF00)':
                                  val>=60?'linear-gradient(90deg,#CC8800,#FFB800)':
                                         'linear-gradient(90deg,#CC1144,#FF3D71)'
                    }} />
                  </div>
                </div>
              ))}
            </div>
          )}

          {/* Live Metrics */}
          {status === 'running' && liveMetrics && (
            <div className="grid-3" style={{marginBottom:'20px'}}>
              {[
                {label:'Knee Angle', value:`${liveMetrics.knee}Â°`},
                {label:'Hip Angle',  value:`${liveMetrics.hip}Â°`},
                {label:'Arm Angle',  value:`${liveMetrics.arm}Â°`},
                {label:'Speed Index',value: liveMetrics.speed},
                {label:'Balance',    value:`${liveMetrics.balance}%`},
                {label:'FPS',        value: fps},
              ].map(m => (
                <div key={m.label} style={{
                  padding:'14px', background:'var(--bg-2)', borderRadius:'10px',
                  border:'1px solid var(--border)', textAlign:'center'
                }}>
                  <div style={{fontSize:'11px', color:'var(--text-dim)', textTransform:'uppercase', letterSpacing:'1px'}}>{m.label}</div>
                  <div style={{fontSize:'22px', fontWeight:'800', color:'var(--primary)', margin:'4px 0'}}>{m.value}</div>
                </div>
              ))}
            </div>
          )}

          {/* Tips when running but no detection yet */}
          {status === 'running' && !liveScores && (
            <div style={{
              background:'rgba(0,229,255,0.05)', border:'1px solid rgba(0,229,255,0.15)',
              borderRadius:'12px', padding:'20px', marginTop:'8px'
            }}>
              <div style={{fontWeight:'700', marginBottom:'10px', color:'var(--primary)'}}>ðŸ’¡ Tips for Best Detection</div>
              <ul style={{marginLeft:'20px', color:'var(--text-dim)', lineHeight:'1.9', fontSize:'14px'}}>
                <li>Stand 2â€“3 metres from the camera so your <strong>full body</strong> is visible</li>
                <li>Face a window or bright light source for better pose detection</li>
                <li>Perform clear athletic movements (jump, run in place, kick, swing)</li>
                <li>Hold each pose for at least 1â€“2 seconds to register</li>
              </ul>
            </div>
          )}

          {/* Idle tips */}
          {status === 'idle' && (
            <div className="grid-2" style={{marginTop:'28px'}}>
              {[
                {icon:'âš¡', title:'Instant Feedback', desc:'Scores update every 1.5 seconds as you move â€” no waiting for upload.'},
                {icon:'ðŸ¦´', title:'Full Skeleton Overlay', desc:'See your pose landmarks drawn live on the camera feed with glowing joints.'},
                {icon:'ðŸ…', title:'12 Sports Supported', desc:'Running, jumping, basketball, soccer, tennis, golf, yoga and more.'},
                {icon:'ðŸ“Š', title:'5 Metrics Tracked', desc:'Form, Power, Consistency, Balance and Timing scored in real time.'},
              ].map(c => (
                <div key={c.title} className="insight-card">
                  <div className="insight-icon">{c.icon}</div>
                  <div className="insight-content">
                    <div className="insight-title">{c.title}</div>
                    <div className="insight-text">{c.desc}</div>
                  </div>
                </div>
              ))}
            </div>
          )}
        </div>
      );
    }

    // Render
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<SXA />);
  </script>
</body>
</html>
